[{"content":"schtasks 可以启用一个定时任务，可以在 Task Scheduler（任务计划程序）中查看或更改权限等： ","date":"2023-12-25T15:54:56+08:00","permalink":"https://hebohang.github.io/p/bat/","title":"Bat"},{"content":"分析工具 SpaceSniffer.exe\n优化C盘 C盘空间占用太大，可以优化：\n关闭睡眠与休眠功能： powercfg -h off\nhttps://answers.microsoft.com/zh-hans/windows/forum/windows_7-performance/answers-%E5%88%86%E4%BA%ABwindows/21af6481-a388-4bb9-896f-7d4885cea3bb\n","date":"2023-12-15T11:40:29+08:00","permalink":"https://hebohang.github.io/p/%E7%94%B5%E8%84%91%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96/","title":"电脑空间优化"},{"content":"案例 头文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;Commandlets/Commandlet.h\u0026#34; #include \u0026#34;Commandlets/ResavePackagesCommandlet.h\u0026#34; #include \u0026#34;XXXCommandlet.generated.h\u0026#34; DECLARE_LOG_CATEGORY_EXTERN(LogXXXCommandlet, All, All); UCLASS() class UXXXCommandlet : public UResavePackagesCommandlet { GENERATED_BODY() public: UXXXCommandlet(); virtual int32 Main(const FString\u0026amp; InCommandline) override; }; 源文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026#34;XXXCommandlet.h\u0026#34; DEFINE_LOG_CATEGORY(LogXXXCommandlet); UXXXCommandlet::UXXXCommandlet() { } int32 UXXXCommandlet::Main(const FString\u0026amp; InCommandline) { // do some thing return 0; } 启动/调试时在vs中增加参数：-skipcompile -run=XXX\n这里的 XXX 换成你想要的名字，UResavePackagesCommandlet 也可以换成 UCommandlet\n本地测试：\n1 .\\UnrealEditor.exe E:\\Work\\xxx.uproject -skipcompile -run=XXX skipcompile参数作用 字面意思就是跳过编译，源码对应位置： 参考 https://zhuanlan.zhihu.com/p/512610557\nhttps://zhuanlan.zhihu.com/p/377903983\n","date":"2023-12-11T15:44:01+08:00","permalink":"https://hebohang.github.io/p/commandlet/","title":"Commandlet"},{"content":"使用 源码 窗口的源码位于： Engine\\Plugins\\Editor\\AssetManagerEditor\\Source\\AssetManagerEditor\\Private\\ReferenceViewer\\SReferenceViewer.cpp\n例如对于关卡 Content/Arts/Maps/Login/Login.umap 做引用分析：\n会根据路径得到一个 FAssetIdentifier，接着在 SReferenceViewer::SetGraphRootIdentifiers 设到slate窗口类的成员变量\tUEdGraph_ReferenceViewer* GraphObj 中的 CurrentGraphRootIdentifiers 里面去：\n接着就会在 UEdGraph_ReferenceViewer 进行递归构造引用与被引用节点，通过 AssetRegistry 来获取：\n","date":"2023-12-01T15:15:26+08:00","permalink":"https://hebohang.github.io/p/referenceviewer/","title":"ReferenceViewer"},{"content":"一些小方法 一些小方法\n贴图设置属性 贴图设置属性\nReferenceViewer ReferenceViewer\nCommandlet Commandlet\n保存资产 https://georgy.dev/posts/save-uobject-to-package/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool SaveToAsset(UObject* ObjectToSave) { UPackage* Package = ObjectToSave-\u0026gt;GetPackage(); const FString PackageName = Package-\u0026gt;GetName(); const FString PackageFileName = FPackageName::LongPackageNameToFilename(PackageName, FPackageName::GetAssetPackageExtension()); FSavePackageArgs SaveArgs; // This is specified just for example { SaveArgs.TopLevelFlags = RF_Public | RF_Standalone; SaveArgs.SaveFlags = SAVE_NoError; } const bool bSucceeded = UPackage::SavePackage(Package, nullptr, *PackageFileName, SaveArgs); if (!bSucceeded) { UE_LOG(LogTemp, Error, TEXT(\u0026#34;Package \u0026#39;%s\u0026#39; wasn\u0026#39;t saved!\u0026#34;), *PackageName) return false; } UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Package \u0026#39;%s\u0026#39; was successfully saved\u0026#34;), *PackageName) return true; } HTTP 请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 bool bHttpRequest = false; FString RequestContent; TSharedRef\u0026lt;TJsonWriter\u0026lt;TCHAR, TPrettyJsonPrintPolicy\u0026lt;TCHAR\u0026gt;\u0026gt;\u0026gt; JsonWriter = TJsonWriterFactory\u0026lt;TCHAR, TPrettyJsonPrintPolicy\u0026lt;TCHAR\u0026gt;\u0026gt;::Create(\u0026amp;RequestContent); JsonWriter-\u0026gt;WriteObjectStart(); JsonWriter-\u0026gt;WriteValue(\u0026#34;xxx\u0026#34;, \u0026#34;xxx\u0026#34;); JsonWriter-\u0026gt;WriteObjectEnd(); JsonWriter-\u0026gt;Close(); FHttpModule\u0026amp; HttpModule = FModuleManager::LoadModuleChecked\u0026lt;FHttpModule\u0026gt;(\u0026#34;HTTP\u0026#34;); TSharedRef\u0026lt;IHttpRequest, ESPMode::ThreadSafe\u0026gt; Request = HttpModule.Get().CreateRequest(); Request-\u0026gt;SetVerb(TEXT(\u0026#34;POST\u0026#34;)); Request-\u0026gt;SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json;charset=UTF-8\u0026#34;); Request-\u0026gt;SetURL(\u0026#34;xxxxxx\u0026#34;); Request-\u0026gt;SetContentAsString(RequestContent); Request-\u0026gt;OnProcessRequestComplete().BindLambda( [\u0026amp;bHttpRequest](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) { bHttpRequest = true; if (bSucceeded) { // do some thing } else { // do some thing } }); Request-\u0026gt;ProcessRequest(); while (!bHttpRequest) { FHttpManager\u0026amp; HttpManager = FHttpModule::Get().GetHttpManager(); HttpManager.Tick(0.0f); FPlatformProcess::Sleep(0.0f); } 注意到，我们这里有一个 flag 标志位 bHttpRequest，是为了确保完成http请求再进行后续的操作（不放在回调里），此时需要使用 HttpManager.Tick\n参考： https://blog.csdn.net/qq_51654332/article/details/131489044\n启动时debug 当我们打了一个游戏包，希望断点调试，可以先启动游戏，然后attach到这个进程：\n但是这样做游戏刚开始进行就无法调试到，我们可以增加参数 -WaitForDebugger：\n（可以alt加鼠标左键拖动exe包，生成一个快捷方式，然后给快捷方式添加启动参数）\n此时会无事发生，点击刚刚的attach按钮会看到这个进程，接着会挂在这里(Engine\\Source\\Runtime\\Launch\\Private\\Launch.cpp)：\n点击continue继续就好了。\n问题合集 1. fatal error C1083: Cannot open compiler generated file 主要是打包的时候出现的：\n1 fatal error C1083: Cannot open compiler generated file: \u0026#39;xxxx\u0026#39;: Permission denied 最后发现是这个 xxxx 文件是只读的，右键属性把只读勾掉就行。\n","date":"2023-12-01T15:01:20+08:00","permalink":"https://hebohang.github.io/p/%E6%9D%82%E9%A1%B9/","title":"杂项"},{"content":"官方文档 https://docs.unrealengine.com/5.3/zh-CN/textures-in-unreal-engine/\nhttps://docs.unrealengine.com/5.3/zh-CN/texture-format-support-and-settings-in-unreal-engine/\n属性 Texture Stream 与 LOD Bias https://polycount.com/discussion/200525/ue4-texture-settings-help-mip-gen-settings-lod-bias-power-of-two-mode\nue 的贴图可以勾选 Never Stream，此时会取消纹理流送；否则默认开启纹理流送。\n关闭纹理流送，就可以保证每次都加载贴图原生大小，保证最高分辨率，但是可能有性能影响，一般ui可以开。\n纹理流送首先加载最小的mipmap，然后逐渐增加；如果 LOD Bias 为0，则最后加载到原贴图最大版本为止；为1则为第一级。例如 2048 的贴图，LOD Bias 为1，则纹理流送到 1024 为止。\nTexture Group 纹理组，可以一起设置贴图的各种设置：默认压缩、mip生成、lod bias等等。\n我们主要在 Device Profiles 设定，引擎路径 Engine\\Config\\BaseDeviceProfiles.ini 下有全局的设定：\n项目Project路径\\Config\\DefaultDeviceProfiles.ini 下有各个设备的重载：\n编辑器编辑入口：\nCook 对于贴图的 Cook 的调用栈为：\n可能的分支： 贴图大小综合作用 贴图有 MaxTextureSize、Lod Bias、Texture Group，我们综合作用下，在cook对应平台时，会根据对应 DeviceProfile 以及贴图对应的 group 设置拿到 对应的 lod bias 等设置，例如我们安卓档配的 lod bias 是1，那么在贴图的 MipGenSettings 不为 TMGS_NoMipmaps 的时候，lod bias 会起作用，这时候 贴图的最后 lod bias 会在原始设置基础上增加安卓挡位的 1\n若有 MaxTextureSize，则会在原来的宽高基础上做对应钳制，钳制完再应用 Lod Bias。\n例如，MaxTextureSize 为 512，贴图设置 Lod Bias 为 2，原始宽为 2048，高 1024，MipGenSettings 不为 TMGS_NoMipmaps，对应到安卓档位的 lod bias 为 1；则在最后打安卓cook的时候： 此时 MaxTextureSize 起作用，首先把宽和高钳制，宽到 512，高到 256；接着计算 lod bias，为原始设置 2 加上安卓档位的 1 为 3，因此宽 512 \u0026raquo; 3 为 64，高 256 \u0026raquo; 3 为 32.\n(这只是大体逻辑，更进一步的还会受到其他因素的影响)\n1 2 3 4 5 6 UDeviceProfile* DeviceProfile = UDeviceProfileManager::Get().FindProfile(\u0026#34;Android\u0026#34;); int32 CookedLODBias = 0; if (DeviceProfile) { CookedLODBias = DeviceProfile-\u0026gt;GetTextureLODSettings()-\u0026gt;CalculateLODBias(Texture, false); } 但是我这里发现，我没有在启用编辑器下，也就是 WITH_EDITOR 是 0 的情况下，我测试的贴图的 GetSurfaceWidth 和 GetSurfaceHeight 一直为0，查了很久也不清楚是为什么。\n最后改为了：\n1 CookedLODBias = DeviceProfile-\u0026gt;GetTextureLODSettings()-\u0026gt;CalculateLODBias(Texture-\u0026gt;Source.GetSizeX(), Texture-\u0026gt;Source.GetSizeY(), Texture-\u0026gt;MaxTextureSize, Texture-\u0026gt;LODGroup, Texture-\u0026gt;LODBias, 0, Texture-\u0026gt;MipGenSettings, Texture-\u0026gt;IsCurrentlyVirtualTextured()); ","date":"2023-11-29T11:11:23+08:00","permalink":"https://hebohang.github.io/p/%E8%B4%B4%E5%9B%BE%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7/","title":"贴图设置属性"},{"content":"条件断点 判断字符串是否相等 我们不能用普通的 operator ==，是因为我们在 Debug Conditions 里面不允许有副作用（Side Effects），因此 只能用有限的几个函数： strlen, wcslen, strnlen, wcsnlen, strcmp, wcscmp, _stricmp, _wcsicmp, strncmp, wcsncmp, _strnicmp, _wcsnicmp, strchr, wcschr, strstr, wcsstr\n错误情况（有 side effects）： C++ 1 s.size() \u0026gt; 0 \u0026amp;\u0026amp; strcmp(\u0026amp;s[0], \u0026#34;abc\u0026#34;) == 0 例子：\n参考： https://blog.csdn.net/sinat_41657218/article/details/124686114\nUE5 1 wcscmp((wchar_t*)MyString.Data.AllocatorInstance.Data,L\u0026#34;MyText\u0026#34;) == 0 例子：\n参考： https://forums.unrealengine.com/t/how-to-compare-a-fstring-in-c-condition-breakpoints/358380\n快捷键 跳转到其他代码文件：Ctrl+T 或 Ctrl+,\n跳转到某一行：Ctrl+G\nhttps://learn.microsoft.com/zh-cn/visualstudio/ide/go-to?view=vs-2022\nhttps://leelongcrazy.com/visual-studioshi-yong-kuai-jie-jian.html\n","date":"2023-11-28T15:48:26+08:00","permalink":"https://hebohang.github.io/p/vs2022/","title":"VS2022"},{"content":"Cook 流程 会执行到 UCookCommandlet 的 main 中： Source\\Editor\\UnrealEd\\Private\\Commandlets\\CookCommandlet.cpp\n参考： https://rootjhon.github.io/posts/%E8%B5%84%E6%BA%90Cook%E6%9E%84%E5%BB%BA/\nCook Content https://docs.unrealengine.com/5.3/zh-CN/cooking-content-in-unreal-engine/\nhttps://docs.unrealengine.com/5.3/zh-CN/build-operations-cooking-packaging-deploying-and-running-projects-in-unreal-engine/\n命令行启动 测试命令：\n1 .\\UnrealEditor-Cmd.exe E:\\Work\\xxx\\xxx.uproject -run=cook -targetplatform=Windows -map=TestMap.umap 这里的 .\\ 一定需要，目录在项目路径的 Engine\\Binaries\\Win64 中；但是 -map 我测试没有起作用，还有待考察。\n测完会放在项目目录的 Saved\\Cooked\\Windows\\ 中。\n编辑器与IDE下启动 编辑器下，我们可以点击cook： 此时 Output Log 会有对应 Commandlet（这里的 xxx 是你的项目路径）：\n1 E:\\Work\\xxx\\Engine\\Binaries\\Win64\\UnrealEditor-Cmd.exe E:\\Work\\xxxxxxx\\C7.uproject -run=Cook -TargetPlatform=Windows -unversioned -fileopenlog -abslog=E:\\Work\\xxx\\Engine\\Programs\\AutomationTool\\Saved\\Cook-2023.11.28-15.04.02.txt -stdout -CrashForUAT -unattended -NoLogTimes -UTF8Output 我们可以把对应参数填入 UE5 项目参数中进行调试：\n此时对于贴图的 Cook 的调用栈为：\n可能的分支： ","date":"2023-11-27T19:38:35+08:00","permalink":"https://hebohang.github.io/p/cook/","title":"Cook"},{"content":"获取关卡中一个 Actor 的被引用情况 背景：做合批的时候剔除被引用的 Actor\n例如： 这里的蓝图类就有一个Level中某Actor的硬引用和一个软引用，对于这两个被引用的Actor我们不应该让他被合批。\n最开始使用的是 IsReferenced 这个接口， 但是发现对于软引用无法获取到。\n但是注意到，对于这种情况，我们直接在 Outliner 面板里删除物体，也会弹出被引用的提示警告。\n这个功能位于 UUnrealEdEngine::DeleteActors （Engine\\Source\\Editor\\UnrealEd\\Private\\EditorActor.cpp）\n分别是两个接口： FBlueprintEditorUtils::GetActorReferenceMap AssetToolsModule.Get().FindSoftReferencesToObjects\n这里特别留意到 ALODActor，之前使用 IsReferenced 接口的时候也发现了被其引用的情况：\n具体是为什么会被 ALODActor 引用还不清楚。\n获取特定类型的所有资产 在 Content/Arts 目录中获取所有 Texture：\n1 2 3 4 5 6 7 FARFilter Filter; Filter.PackagePaths.Add(\u0026#34;/Game/Arts\u0026#34;); Filter.ClassPaths.Add(UTexture::StaticClass()-\u0026gt;GetClassPathName()); Filter.bRecursivePaths = true; Filter.bRecursiveClasses = true; TArray\u0026lt;FAssetData\u0026gt; TextureAssets; AssetRegistry.GetAssets(Filter, TextureAssets); 这里注意，我们在 5.1 之后使用的是 ClassPaths 而不是 ClassNames： 获取资产的引用关系 例如获取当前关卡的引用关系：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto World = GEditor-\u0026gt;GetEditorWorldContext().World(); FName Name = World-\u0026gt;GetPackage()-\u0026gt;GetFName(); FAssetRegistryModule\u0026amp; AssetRegistryModule = FModuleManager::GetModuleChecked\u0026lt;FAssetRegistryModule\u0026gt;(\u0026#34;AssetRegistry\u0026#34;); TArray\u0026lt;FName\u0026gt; DependentAssets; AssetRegistryModule.Get().GetDependencies(Name, DependentAssets, UE::AssetRegistry::EDependencyCategory::All); for (int32 i = 0; i \u0026lt; DependentAssets.Num(); ++i) { TArray\u0026lt;FAssetData\u0026gt; OutAssetData; AssetRegistryModule.Get().GetAssetsByPackageName(DependentAssets[i], OutAssetData); if (!OutAssetData.IsEmpty()) { UObject* AssetInPackage = OutAssetData[0].GetAsset(); } } 关于 AssetRegistry，可以参考： https://zhuanlan.zhihu.com/p/76964514\n","date":"2023-11-23T18:01:40+08:00","permalink":"https://hebohang.github.io/p/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%96%B9%E6%B3%95/","title":"一些小方法"},{"content":"选择 UE的官方源码是用git管理的： https://github.com/EpicGames/UnrealEngine\n不过项目管理他们更推荐P4（Perforce）\nP4 对于代码文本的管理有些蛋疼，很多项目喜欢混合 git、svn、perforce 使用。\n编辑器 编辑器右下角就有 Source Control 一栏，连上版本控制后我们可以进行 提交、revert 等功能。 点开设置可以进行连接选项的填写：\n源码 由于有这么多种版本控制，ue 统一抽出了接口，位于： Engine\\Source\\Developer\\SourceControl，可以重点观察 Engine/Source/Developer/SourceControl/Public/ISourceControlProvider.h\n例如 P4 则是实现这一接口： Engine/Plugins/Developer/PerforceSourceControl/Source/PerforceSourceControl/Private/PerforceSourceControlProvider.h\n","date":"2023-11-22T20:22:04+08:00","permalink":"https://hebohang.github.io/p/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/","title":"版本控制"},{"content":"UE 官方主推 P4，在二进制文件上他有加锁的机制，还算能用，但是很贵。\n安装 下载地址： https://www.perforce.com/downloads/helix-visual-client-p4v\nP4最好默认安装在C盘，与后续的UGS使用设置有关。\nP4V 我们的 Depot 和 Workspace 是一个一一对应关系，因此对哪个进行 Checkout 都是一样的。\n1. Reconcile Offline Work 对于没有 Checkout 的文件，默认是锁住的，是一个只读状态。如果我们没有连接 P4 但是又更改为可写状态在其他地方进行了更改，此时就不会加入到 Pending 里面。 （我之前就犯了这个错误，vs连接p4失败了，于是漏了文件没传上去，导致项目构建失败）\n我们可以右键点击 Reconcile Offline Work 来检查一下有没有漏的文件：\n这个指令也就是让 Change list 和本地的情况一致。\n2. Revert Unchanged Files 第二个好用的指令是这个：\n可以自动 Revert 掉没有更改但是被checkout的文件。\nIDE VS2022 对于 VS2022，我们需要安装 P4VS 插件： 此时就可以在Tools-\u0026gt;Options里进行设置： 这里我认为很好用的一个设置是：\n那样对于可写的文件，在保存的时候就会自动 Checkout 上，这样就不用担心漏checkout的问题了。\nRider 由于觉得 VS2022 对于写 UE 有不方便之处，我还是切到了 Rider，对于 Rider 官方就支持 Perforce，无需安装任何插件。\n我们只需要填好这两处即可：\n如果还没生效重启一下就可以了。\n命令行 背景 美术反馈有一个文件，mark for add会报错 Cannot check out \u0026ldquo;exclusive open\u0026rdquo; file(s)，重命名为其他名字就可以add上。\n怀疑是其他人也对同样名字的文件mark for add，但是没有提交，导致被锁住了，p4v里头又看不到是谁，所以就借助命令行查看了。\n初始化p4 1 2 3 4 5 6 7 8 # 设置服务端地址 p4 set P4PORT=perforce.example.com:1666 # 设置 Perforce 用户名 p4 set P4USER=\u0026lt;your-username\u0026gt; # 登录到 Perforce 帐户 p4 login # 输入密码后，设置工作目录 p4 set P4CLIENT=\u0026lt;your-client-workspace\u0026gt; 接着对那个文件使用 opened -a ：\n1 p4 opened -a [filepath] ","date":"2023-11-21T16:03:52+08:00","permalink":"https://hebohang.github.io/p/perforce/","title":"Perforce"},{"content":"World Partition 官方文档：\nhttps://docs.unrealengine.com/5.0/zh-CN/world-partition-in-unreal-engine/\n主要是服务于大世界，提供了自动数据管理和基于距离进行加载的关卡流送系统。每个关卡分为是不是 World Partition（下称为WP）的版本，我们可以通过：\n1 2 3 4 UWorld* World = GEditor-\u0026gt;GetEditorWorldContext().World(); if (World-\u0026gt;IsPartitionedWorld()) { } 来判断。\n非WP关卡转换为WP关卡 LandscapeSpline LandscapeSpline与World Partition相关。\n核心函数： LandscapeEdModeSplineTools.cpp： BeginTool、AddControlPoint、AddSegment\nWorldPartition中，特殊的 ALandscapeSplineActor 的Owner是空的，他是通过 LandscapeGuid 和 LandscapeActor 附着到一个 ALandscape 上的。Outer是这个UWorld.\n非 WP 版本，是全部塞到一个 ALandscapeProxy 里面，一个 landscap e有一个 ALandscapeProxy，ALandscapeProxy 里面挂有 ULandscapeSplinesComponent，ULandscapeSplinesComponent， 里面有Segment数组和Control Point数组；\nWP版本则是每个landscape可以挂上多个 ALandscapeSplineActor，每个 ALandscapeSplineActor 里面挂有 ULandscapeSplinesComponent。\nWP-HLOD 还不太清楚 WP 版本的 HLOD 和正常的有什么区别，文档： https://docs.unrealengine.com/5.0/zh-CN/world-partition---hierarchical-level-of-detail-in-unreal-engine/\nOFPA (One File Per Actor) https://zhuanlan.zhihu.com/p/502063482\nWorld Partition下默认开启，非 WP 关卡可以在这里打开：\nISM 与 HISM ISM（Instanced Static Meshes）学过图形学的应该都不陌生，走的dc的api接口都有所区别。但是 ISM 需要所有的 Instance 都具有相同的 LOD，也就是说如果远处和近处都是用 ISM 一起渲染的，他们仍然要是一级LOD； 因此对于植被而言，通常覆盖范围较广，但是我们不可能远处和近处都用LOD0，因此又推出了 HISM（Hierarchical instanced static mesh），他把所有的 Instance 分簇，每一簇使用一级 LOD 层。\n因此 HISM 可能每一簇是一个 dc，虽然多了 dc 以及组织结构的管理消耗，但是剔除会更加方便。\n具体原理可以参考：\nhttps://zhuanlan.zhihu.com/p/58963258\nhttps://zhuanlan.zhihu.com/p/441958089\nhttps://zhuanlan.zhihu.com/p/443809005\nhttps://zhuanlan.zhihu.com/p/42949773\n参考： https://www.intel.com/content/www/us/en/developer/articles/training/unreal-engine-4-optimization-tutorial-part-2.html\nHLOD 官方文档： https://docs.unrealengine.com/5.0/zh-CN/hierarchical-level-of-detail-in-unreal-engine/\n针对静态Mesh资产的功能，当模型处于远距离时，分层细节级别（HLOD）系统可以将多个静态网格体Actor合并成单个代理网格体和材质。 生成代理网格体是需要花时间的步骤，并且每次编辑完场景时，左上角可能有需要重新构建HLOD代理网格体的提示（有点像灯光一样，也是有重新构建灯光的步骤）。\nActor合并 一共有四种功能：Merge、Simplify、Batch、Approximate，每一种功能都可以在下面的 Merge Actors Settings 里面进行设置配置。\n官方文档： https://docs.unrealengine.com/5.0/zh-CN/merging-actors-in-unreal-engine/\n相关代码 UE 自带的这个合并功能，其中的 Batch 已经可以达到合批的功能了，其中注册到Editor的主要代码在：\nvoid FLevelEditorContextMenuImpl::FillMergeActorsMenu(UToolMenu* Menu);\n具体功能则是在 IMergeActorsTool 的接口 RunMergeFromSelection 中，可以参考做 Batch 的时候的调用栈：\n做 Batch 的核心函数位于 MeshMergeUtilities.cpp：FMeshMergeUtilities::MergeComponentsToInstances\nbReplaceSourceActors 可以指定是否要把之前的Actor替换为合并后的模型；其中在 FMeshInstancingSettings 可以指定是否依赖 HLOD Volume，可以指定 ISMComponentToUse （我们可以在这里换成 UHierarchicalInstancedStaticMeshComponent::StaticClass()），这个设置就和面板中的是对应起来的。\n最后这个 Batch 功能就可以做到：对于选中的所有 Static Mesh 的 Actor，若能合并（材质、Mesh相同）则合并为一个 HISM，一个 HLOD Volumn 内的要单独合成一个；并且 我们可以指定最小的应该合并的数量（FMeshInstancingSettings-InstanceReplacementThreshold），指定为5就需要有5个能合并的物体才会去合。\n源码修改 如果是HISM，则把HISM内的Instance给重新加入到合批中 这里还把之前的注释掉了，因为我们之前的 HISM 的 Actor 类型就是一个 AActor，会与设置中最后合批的类型 ActorClassToUse 相同，我们不希望被跳过：\nUE源码这里没有指定初始值，经过测试这里的 HLODVolume 可能会沿用之前的 HLODVolume 值，导致最后合批不严格按照 HLODVolume 划分。 我在这里补上了初始值。 组织方式修改：原来ue的功能会把所有不同的mesh都合成一个actor，一种mesh挂一个 ISM 或者 HISM，我们应该是希望一种mesh一个actor 调试一下是这样的：\n核心代码在 FMeshMergeUtilities::MergeComponentsToInstances 的：\n我们这里把 MergedActor 从类 FActorEntry 转移到 FComponentEntry 中了，就完成了我们想要的效果。\n补充说明 可能会改到相关材质资产，比如增加flag bUsedWithInstancedStaticMeshes:\n一键生成碰撞 打开一个 Static Mesh 的资产，在 Collision 这里，如果有 Primitives，则是简单碰撞，一般美术自己编辑的碰撞信息 最后也会进这里面：\n但是如果一个物体没有简单碰撞，UE 则会自动生成一个复杂碰撞（即三角面的碰撞体）：\n这样太费了，我们希望做的是遍历场景所有 Mesh，检查是否有简单碰撞，若没有则自动生成。UE 是有自动生成接口的：\n我们希望生成的是 DOP 的或者 Convex 的。\n相关代码 对应的碰撞信息位于：StaticMesh-\u0026gt;GetBodySetup()-\u0026gt;AggGeom.GetElementCount()\n","date":"2023-11-20T17:27:45+08:00","permalink":"https://hebohang.github.io/p/%E5%9C%BA%E6%99%AF%E4%BC%98%E5%8C%96/","title":"场景优化"},{"content":"ContentBrowser 扩展 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 UToolMenu* Menu = UToolMenus::Get()-\u0026gt;ExtendMenu(\u0026#34;ContentBrowser.AssetContextMenu.AssetActionsSubMenu\u0026#34;); FToolMenuSection\u0026amp; Section = Menu-\u0026gt;FindOrAddSection(\u0026#34;AssetContextAdvancedActions\u0026#34;); Section.AddMenuEntry( \u0026#34;HbhTest\u0026#34;, LOCTEXT(\u0026#34;Hbh Test Title\u0026#34;, \u0026#34;Hbh Test1\u0026#34;), LOCTEXT(\u0026#34;Hbh Test TooltipText\u0026#34;, \u0026#34;Hbh Test2\u0026#34;), FSlateIcon(), FToolMenuExecuteAction::CreateLambda([this](const FToolMenuContext\u0026amp; InContext) { if (UContentBrowserAssetContextMenuContext* Context = InContext.FindContext\u0026lt;UContentBrowserAssetContextMenuContext\u0026gt;()) { for (UObject* Asset : Context-\u0026gt;GetSelectedObjects()) { UE_LOG(LogTemp, Log, TEXT(\u0026#34;%s\u0026#34;), *Asset-\u0026gt;GetPathName()); } } }) ); 对资产右键，效果： 弹窗 自定义一个弹窗：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static const FName TabName(\u0026#34;Your Tab Name\u0026#34;); FGlobalTabmanager::Get()-\u0026gt;RegisterNomadTabSpawner(TabName, FOnSpawnTab::CreateRaw(this, \u0026amp;OnSpawnTab)) .SetDisplayName(LOCTEXT(\u0026#34;xxx\u0026#34;, \u0026#34;xxx\u0026#34;)) .SetMenuType(ETabSpawnerMenuType::Hidden); FGlobalTabmanager::Get()-\u0026gt;UnregisterNomadTabSpawner(TabName); FGlobalTabmanager::Get()-\u0026gt;TryInvokeTab(TabName); TSharedRef\u0026lt;SDockTab\u0026gt; OnSpawnTab(const FSpawnTabArgs\u0026amp; SpawnTabArgs) { return SNew(SDockTab) .TabRole(ETabRole::NomadTab) [ SNew(xxx) ]; } 如果只是想要一个弹出窗口显示信息，可以直接使用 FMessageDialog：\nhttps://docs.unrealengine.com/5.3/en-US/API/Runtime/Core/Misc/FMessageDialog/\nhttps://zhuanlan.zhihu.com/p/268069477\n1 2 3 4 5 FMessageDialog::Open(EAppMsgType::Ok, NSLOCTEXT(\u0026#34;xx\u0026#34;, \u0026#34;xxx\u0026#34;)); int32 Count = 32; FString Dialog = FString::Printf(TEXT(\u0026#34;%d\u0026#34;), Count); FMessageDialog::Open(EAppMsgType::Ok, FText::FromString(Dialog)); 进度条 1 2 3 4 5 6 7 8 9 10 #include \u0026#34;Misc/ScopedSlowTask.h\u0026#34; FScopedSlowTask SlowTask(files.Num(), LOCTEXT(\u0026#34;GeneratingDataText\u0026#34;, \u0026#34;Generating Data\u0026#34;)); SlowTask.MakeDialog(); for (auto\u0026amp; file : files) { SlowTask.EnterProgressFrame();\t//Implementation can be before or after } 参考：\nhttps://forums.unrealengine.com/t/how-can-i-use-unreal-engine-editors-progress-bar-not-umg/359876\nhttps://docs.unrealengine.com/5.3/en-US/API/Runtime/Core/Misc/FScopedSlowTask/\n","date":"2023-11-20T15:28:35+08:00","permalink":"https://hebohang.github.io/p/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95/","title":"编辑器扩展"},{"content":"编译链接 源码编译 1 git clone -b 4.27.2-release --depth=1 git@github.com:EpicGames/UnrealEngine.git https://zhuanlan.zhihu.com/p/107516361\nUE模块、类相关 [YourModuleName]_API宏的作用? 放函数声明前用于暴露(导出)该函数\n放类声明前用于暴露(导出)该类的所有内容\n特别注意：_API前面的内容一定要大写！否则会编译不通过\nMinimalAPI说明符的作用?\n暴露(导出)该类的类型信息让其它模块可以\nCast到该类型 继承该类型 (该类型的所有定义在.cpp文件的虚函数都需要导出) 使用内联函数 UI 勾掉 auto wrap text，就可以控制自动换行的文本大小（有wrap控制的情况下？）。\n资产 Texture Texture Stream 与 LOD Bias https://polycount.com/discussion/200525/ue4-texture-settings-help-mip-gen-settings-lod-bias-power-of-two-mode\nue 的贴图可以勾选 Never Stream，此时会取消纹理流送；否则默认开启纹理流送。\n关闭纹理流送，就可以保证每次都加载贴图原生大小，保证最高分辨率，但是可能有性能影响，一般ui可以开。\n纹理流送首先加载最小的mipmap，然后逐渐增加；如果 LOD Bias 为0，则最后加载到原贴图最大版本为止；为1则为第一级。例如 2048 的贴图，LOD Bias 为1，则纹理流送到 1024 为止。\nTexture Group 纹理组，可以一起设置贴图的各种设置：默认压缩、mip生成、lod bias等等。\nC++ ue反射相关 入门： https://zhuanlan.zhihu.com/p/400473355 https://www.cnblogs.com/ghl_carmack/p/5701862.html https://ikrima.dev/ue4guide/engine-programming/uobject-reflection/uobject-reflection/\nClass Default Object, 简称CDO UCLASS宏为UObject提供了一个描述其基于虚幻的类型的UCLASS的引用。每个UCLASS都维护一个名为“类默认对象”的对象，简称CDO。\nCDO本质上是一个默认的“模板”对象，由类构造函数生成，之后未修改。可以为给定的Object实例检索UCLASS和CDO，尽管它们通常应该被认为是只读的。可以使用GetClass()函数随时访问Object实例的UCLASS。\nCDO是在引擎初始化时创建的，当引擎为每个类生成UClass对象时。每个UClass的实例都是在引擎初始化期间创建的，并被分配为该UClass的CDO。并且包含在反射系统中，如在编辑器可以操作类蓝图。Obj.cpp可以看到引擎CDO初始化创建。\n因此一个 UClass* 是无法直接Cast转型成其他类型的，因为没有实例化；我们可以用 TSubclassOf 先转为其他类型，之后获取 CDO 得到默认对象（GetDefaultObject\u0026lt;xxx\u0026gt;）再调用它的相关函数之类的。\n获取UObject属性值 https://zhuanlan.zhihu.com/p/61042237\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 获取属性名为PropertyName的属性的值 UObject* Object = ...; FName PropertyName = ...; FProperty* Property = Object-\u0026gt;GetClass()-\u0026gt;FindPropertyByName(PropertyName); if(Property) { void* ValuePtr = Property-\u0026gt;ContainerPtrToValuePtr\u0026lt;void\u0026gt;(Object); if(ValuePtr) { FString Value; Property-\u0026gt;ExportTextItem(Value, ValuePtr, nullptr, nullptr, PPF_None); UE_LOG(LogTemp, Log, TEXT(\u0026#34;Property %s value is %s\u0026#34;), *PropertyName.ToString(), *Value); } } 标记宏 可以使用UENUM()、UCLASS()、USTRUCT()、UFUNCTION()、UPROPERTY()来标记不同的类型和成员变量，标记也可以包含额外的描述关键字。\n每个描述的关键字（例如EditAnywhere或BlueprintCallable）都在ObjectMacros.h中有一个镜像，有一个简短的描述。当不知道一个关键字的意思时，可以去ObjectMacros.h中去查看\n更方便地是直接看文档： https://docs.unrealengine.com/5.3/zh-CN/ufunctions-in-unreal-engine/\n类说明符 UCLASS https://docs.unrealengine.com/5.3/zh-CN/class-specifiers/\n蓝图 UPARAM(ref) https://docs.unrealengine.com/5.3/zh-CN/exposing-gameplay-elements-to-blueprints-visual-scripting-in-unreal-engine/\n指针和引用 参考： https://zhuanlan.zhihu.com/p/604213414\n类指针 UClass* 和 TSubClassOf\n软引用和硬引用 硬引用在资产加载时的逻辑：当A资产持有B资产的硬引用时，A资产被加载到内存中时，B资产也会被加载到内存中。\n软引用在资产加载时的逻辑：当A资产持有B资产的软引用是，A资产被加载到内存中时，B资产不会被加载。\n软引用本质上存的是资产的路径。\n软对象引用：TSoftObjectPtr\u0026lt;T\u0026gt; SoftObjRef;\n软类引用：TSoftClassPtr\u0026lt;T\u0026gt; SoftClassRef;\n因此软引用主要是用来做异步加载的，参考：\nhttps://docs.unrealengine.com/5.3/zh-CN/asynchronous-asset-loading-in-unreal-engine/\nhttps://docs.unrealengine.com/5.3/zh-CN/referencing-assets-in-unreal-engine/\nhttps://zhuanlan.zhihu.com/p/351106187\n源码分析 看类：FSoftObjectPath\n有成员变量： 看注释也知道他是指向一个 Level 中的 Object 的路径，因此持有软引用的时候加载并不会加载资产，可以用 IsPending() 方法来判断是否可以访问。\n继承关系：TSoftObjectPtr 只是对 FSoftObjectPtr 的一个 Wrapper，FSoftObjectPtr 继承自 TPersistentObjectPtr\u0026lt;FSoftObjectPath\u0026gt;\n字符串处理 FString、FName、FText互转 https://docs.unrealengine.com/5.3/zh-CN/string-handling-in-unreal-engine/\n中文乱码 使用 UTF8_TO_TCHAR：\n1 TextBlock-\u0026gt;SetText(FText::FromString(UTF8_TO_TCHAR(\u0026#34;否\u0026#34;))); 本地化 本地化主要是根据LOCTEXT或者NSLOCTEXT将这两个里面的LOCTEXT(“key”, “value”), 找到这个key，然后根据不同语言，将我们的Value替换掉\n添加namespace域，一方面为了过滤，一方面避免了key冲突。\nLOCTEXT用法\n前后必须要加LOCTEXT_NAMESPACE 和LOCTEXT_NAMESPACE定义一个作用域， 代表下面的字符串都在这里作用域里头，引擎好通过这个域去搜索所有的LOCTEXT\n1 2 3 4 5 #define LOCTEXT_NAMESPACE \u0026#34;SlateMain\u0026#34; .Text(LOCTEXT(\u0026#34;SMainSlate_ButtonSlateAnimation_Text3333\u0026#34;, \u0026#34;测试Slate动画\u0026#34;)) #undef LOCTEXT_NAMESPACE NSLOCTEXT用法\n不用加LOCTEXT_NAMESPACE 和LOCTEXT_NAMESPACE。但是三个参数，第一个也是作用域\n1 .Text(LOCTEXT(\u0026#34;SlateMain\u0026#34;, \u0026#34;SMainSlate_ButtonSlateAnimation_Text3333\u0026#34;, \u0026#34;测试Slate动画\u0026#34;)) UE5在编辑器的 Tools-\u0026gt;Localization Dashboard 中配置： 参考： https://blog.csdn.net/u011718663/article/details/117785611\nhttps://forums.unrealengine.com/t/define-loctext-namespace-something/438086\n复制 Duplicate 1 2 3 4 5 6 7 8 9 10 // 1. Duplicate Object YourType* NewObject = DuplicateObject\u0026lt;YourType\u0026gt;(const TObjectPtr\u0026lt;T\u0026gt;\u0026amp; SourceObject, UObject* Outer, const FName Name = NAME_None) // 2. Duplicate Actor UEditorActorSubsystem* EditorActorSubsystem = GEditor-\u0026gt;GetEditorSubsystem\u0026lt;UEditorActorSubsystem\u0026gt;(); YourType* NewActor = Cast\u0026lt;YourType\u0026gt;(EditorActorSubsystem-\u0026gt;DuplicateActor(YourActor, World)); // 3. Duplicate Asset FAssetToolsModule\u0026amp; AssetToolsModule = FModuleManager::LoadModuleChecked\u0026lt;FAssetToolsModule\u0026gt;(\u0026#34;AssetTools\u0026#34;); UObject* NewAsset = AssetToolsModule.Get().DuplicateAsset(\u0026#34;NewAssetName\u0026#34;, \u0026#34;NewAssetPath\u0026#34;, YourAsset); Slate专栏 快速入门指南 官方教程： https://docs.unrealengine.com/5.0/zh-CN/slate-editor-window-quickstart-guide-for-unreal-engine/\n但是官方教程有一点错误，详细代码可以看： https://github.com/yegorsw/UE_SimpleSlatePlugin/tree/main\n细节面板自定义 https://zhuanlan.zhihu.com/p/463008792\nhttps://imzlp.com/posts/26919/\n其中若是对TArray类型自定义，我是参考的ue源代码，参考链接： https://forums.unrealengine.com/t/how-to-use-ipropertytypecustomization-to-display-tarray/414634/7\n最后翻看ue代码：FSpriteDetailsCustomization::BuildTextureSection\n1 2 3 TSharedRef\u0026lt;FDetailArrayBuilder\u0026gt; PropertyValuesBuilder = MakeShareable(new FDetailArrayBuilder(PropertyValuesHandle.ToSharedRef())); PropertyValuesBuilder-\u0026gt;OnGenerateArrayElementWidget(FOnGenerateArrayElementWidget::CreateSP(this, \u0026amp;FKCustomPropertyDetails::GeneratePropertyValueWidget)); StructBuilder.AddCustomBuilder(PropertyValuesBuilder); 关闭代码文件优化 https://zhuanlan.zhihu.com/p/563164847 可以按vs的方式：\n1 2 #pragma optimize(\u0026#34;\u0026#34;, off) #pragma optimize(\u0026#34;\u0026#34;, on) ","date":"2023-11-17T15:56:23+08:00","permalink":"https://hebohang.github.io/p/ue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"UE基础知识"},{"content":"常用命令 1 2 3 4 5 6 7 8 # 本地预览 hugo server # 预览特定config hugo --config=config-HEngine.yaml server # 新建文章（指定文章路径） hugo new post/xxx/xxx/index.md # 提交 git add .;git commit -m \u0026#34;update\u0026#34;;git push Hugo链接 官方文档： https://gohugo.io/documentation/\n官方git： https://github.com/gohugoio/hugo\nHugo+Stack 环境配置 我们选用的是stack主题： https://github.com/CaiJimmy/hugo-theme-stack\n快速入门版本 最开始，我们使用的是stack官方给的快速上手版本：https://github.com/CaiJimmy/hugo-theme-stack-starter ，这个版本直接使用 Hugo module 给串联起来，并且可以直接使用 GitHub 的 codespace 直接上手写博客。\n但是用这种版本会有一些问题：\ncodespace启动较慢，不如本地写 因为没有用源码，所以要么是自己fork一份stack theme再改自己仓库对应的主题地址，要么就不能对主题进行定制化修改 基于此，最后我还是选择了源码+本地环境配置的写法。当然 codespace 仍然是可以用的。\n本地环境配置 安装hugo\n根据官方建议，我们选择下载扩展版本： 根据我的本机环境，我下载的是hugo_extended_0.120.4_windows-amd64.zip版本。\n安装完成后可以用 hugo version 查看版本，检查是否安装成功。\n安装go语言\nhugo选择是go作为构建语言，这种编译型的语言有着天然的速度优势，因此几乎可以做到实时预览，这也是我选择hugo的主要原因。\n初始化博客环境\nhugo new site blog\n这样就会新建立blog文件夹，并且包含hugo的基本环境。\n下载主题源码\n我这里选用的stack主题，直接在stack的仓库拉一份release版本的，放在我们刚刚的博客环境中的themes文件夹中（若没有则新建）。\n一般主题都会有一个 exampleSite 文件夹，拷贝到博客根目录就ok了。\nCI流程 博客仓库托管于 Github，我们自然是使用 Github Action 进行自动部署的 CI（continuous integration）流程。事实上，前面的stack快速版本就已经给了这样的文件了。\n但是不幸的是他还有点问题，他的部署流程使用的是 JamesIves/github-pages-deploy-action@v4，但是我没有成功。我最后改成了使用 peaceiris/actions-gh-pages@v3：\n1 2 3 4 5 6 7 8 - name: Deploy 🚀 uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: 这里填写你的 GitHub 的 token EXTERNAL_REPOSITORY: 这里填你部署的地址，我的是 hebohang/hebohang.github.io PUBLISH_BRANCH: hugo PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 关于TOKEN 这里需要注意，我们应该给token对应的权限以让他可以使用 GitHub Workflow（而之前hexo的部署是使用hexo指令的，就没有加权限的步骤）。\n使用多个主题 本地可以这样测试：hugo --config=config-HEngine.yaml server\n使用多个config以指定不同的theme。\nhttps://discourse.gohugo.io/t/two-themes-as-separate-hugo-directories-deployed-to-the-same-website/27899/4\nhttps://github.com/peaceiris/actions-gh-pages/issues/324\n关于stack主题 文档：https://stack.jimmycai.com/config/menu\n说明 博客中链接需要单独起一行才生效。 如果创建多级文件夹时文章文件名不是 index.md 或者类别、标签文件名不是 _index.md 的话，设置封面图片会出现问题。 扩展 代码块 tab为4个字符宽不生效 参考：\nhttps://discourse.gohugo.io/t/chroma-syntax-highlighter-and-tabwidth/31455/5\n需要在 themes\\hugo-theme-stack\\assets\\scss\\partials\\highlight\\common.scss 后面添加：\n1 2 3 pre.chroma { -moz-tab-size:4;-o-tab-size:4;tab-size:4; } 开启waline评论 主要见此链接： https://waline.js.org/guide/get-started/\n一直配置完 Vercel 部署这一步：\n点击 Visit，此时的网址即为服务端地址，然后直接填到 Stack 模板中：\n即可开启 waline 评论。\n参考： https://imayx.top/waline/\nSub Category 我一直想要这个功能，目前看到最漂亮的是 Jekyll 的主题 chirpy，演示Demo： https://chirpy.cotes.page/\n但是 Hugo 似乎支持的不好，看到一个一样想法的相关讨论： https://discourse.gohugo.io/t/categories-sections-with-hierarchy/3058\n但是 Hugo 也看到一个移植过来的主题实现了这个功能： https://github.com/kakawait/hugo-tranquilpeak-theme\n之后再试试。\n归档三栏 在 /assets/scss/custom.scss 中加入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 归档页面三栏 @media (min-width: 1024px) { .article-list--compact { display: grid; grid-template-columns: 1fr 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; border-radius: 16px; } } } 参考： https://www.xalaok.top/post/stack-modify/#%E5%8F%8C%E6%A0%8F\n最后更新时间 hugo-theme-stack\\layouts\\_default\\single.html\n但是这里我在 single.html 中加了总有点不对，去掉也能作用，只是没有按照想要的格式，按照默认的格式去作用的。 后来发现只是本地测试正确，部署之后显示还是不太对。目前没有启用这一功能了。\n参考： https://blog.yfei.page/cn/2021/03/lastmod-hugo/\n页面宽度 调整 themes\\hugo-theme-stack\\assets\\scss\\grid.scss\n图片糊 我把这里调成false就好了： 更进一步或许该参考： https://gohugo.io/content-management/image-processing/\n参考链接 https://yelleis.top/p/61fdb627/#%E6%98%BE%E7%A4%BA%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E6%96%87%E7%AB%A0%E6%95%B0%E7%9B%AE\n参考 https://blog.reincarnatey.net/2023/build-hugo-blog-with-stack-mod/#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2\nhttps://digitaldrummerj.me/series/blogging-with-hugo/\n","date":"2023-11-15T16:20:34+08:00","image":"https://hebohang.github.io/p/hugo/image-1_hu8bfe0da041acf9635cac8731e36b058a_148455_120x120_fill_box_smart1_3.png","permalink":"https://hebohang.github.io/p/hugo/","title":"Hugo"},{"content":"建站选型 博客分静态博客和动态博客，静态博客维护成本小，因此我这里选择的是静态博客的方式。主流的几个静态博客框架是jekyll、hexo和hugo，我们这里使用的是 Hexo 进行静态博客的生成，随后部署在Github Pages上。\n主要参考的链接是：https://blog.csdn.net/yaorongke/article/details/119089190\n关于Hexo 文档：documentation\n疑问：troubleshooting\nGithub：GitHub\n常用指令 Windows Powershell 多个指令不能用 \u0026amp;\u0026amp; 了，我们可以使用分号 ;\n我的常用指令：\n1 2 3 4 5 hexo clean hexo g hexo s hexo d hexo g -d 因此本地测试我们可以直接：\n1 hexo clean; hexo g; hexo s 一步到位。\n部署的时候可以：\n1 hexo clean; hexo g; hexo d 或者\n1 hexo g -d Quick Start 新建博客 1 $ hexo new \u0026#34;My New Post\u0026#34; More info: Writing\n本地起一个服务器 1 $ hexo server More info: Server\n主要是用于本地自测，可以简单用写： hexo s\nGenerate static files 1 $ hexo generate More info: Generating\n本地生成，hexo g 一键部署.\nDeploy to remote sites 1 $ hexo deploy More info: Deployment\n我们配好部署网站后端后，就可以直接用 hexo g -d\n关于Next 我们选择的主题theme是Next主题，参考使用文档： https://theme-next.iissnan.com/getting-started.html\nGithub位置：https://github.com/theme-next/hexo-theme-next\n","date":"2023-11-11T16:17:13+08:00","permalink":"https://hebohang.github.io/p/hexo/","title":"Hexo"},{"content":"静态博客与动态博客 静态博客和动态博客是两种不同类型的博客系统。\n区别 静态博客是把所有的博客文章预先生成好的静态页面，并存储在服务器上。当用户请求访问某篇博客时，服务器会直接返回对应的静态页面，不需要动态生成。 因此，静态博客通常比较快，安全性也较高，但是缺点是不能提供动态内容，例如评论功能，数据统计功能等。 不过我们可以想办法做到无后端的模拟动态的行为，比如说 Valine 就是一个无后端的评论系统。\n动态博客则是在用户请求时才动态生成博客页面。动态博客通常可以提供更多的功能，例如评论，数据统计，分类标签等。 但是，动态博客的响应速度较慢，安全性也较低，因为每次请求都需要从数据库中动态生成博客页面。\n流行框架 静态博客的流行框架有： Jekyll、 Hexo 和 Hugo\n动态博客的流行框架有： Typecho、 WordPress 和 zblog\n选择 我只是打算整理好笔记，以供自己以后翻阅以及分享给其他人查阅，并不想折腾后端，因此选择了免费的方案： 选一个静态博客框架 + Github Pages 部署。\nHexo 最初我选择的是 Hexo，他使用 nodejs 作为编译所用语言（因为静态博客最后都得编译成静态的html类型）， 选用的 Next 主题，参见：Hexo\n但是感觉编译起来有点难受，我是把博客源文件单独上传到一个仓库：\nhttps://github.com/hebohang/HebohangWebsiteHexo\n每次调用 Hexo 指令再去部署的。主要是每次编译需要花一点时间，不过已经挺快了，知道我遇见了 Hugo。\nHugo Hugo 使用 go 作为编译所用语言，静态型编程语言就是飞快，基本上所见即所得了， 选用的 Stack 主题，参见：Hugo\nJekyll Jekyll 我暂时没有尝试过，听说构建时间比较慢，但是似乎有加速方法？\n但是看到一个主题 chirpy，演示Demo： https://chirpy.cotes.page/\n尤其是这个 Categories 的设计让我觉得很不错。\n","date":"2023-10-21T20:18:02+08:00","permalink":"https://hebohang.github.io/p/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2%E4%B8%8E%E9%80%89%E6%8B%A9/","title":"静态博客、动态博客与选择"},{"content":"想切换成 ssh 协议来 push https://stackoverflow.com/questions/14762034/push-to-github-without-a-password-using-ssh-key\n示例： git add xxx git commit -m \u0026quot;xxx\u0026quot; git remote set-url origin git@github.com:hebohang/glfw.git git push\n错误记录 git submodule: \u0026ldquo;already exists in the index\u0026rdquo; https://stackoverflow.com/questions/12898278/issue-with-adding-common-code-as-git-submodule-already-exists-in-the-index\nOpenSSL SSL_read: git clone 的时候发生的错误。\n这是服务器的SSL证书没有经过第三方机构的签署，所以报错。\n解决方法：git config --global http.sslVerify \u0026quot;false\u0026quot;\nhttps://www.cnblogs.com/jfen625/p/12995408.html\n文件夹大小写问题 貌似 Windows 默认不分大小写，但是我们可以在项目的：.git-\u0026gt;config 中将 ignorecase 手动改为 false\n更新版本 Windows：git bash git update-git-for-windows\n一些参数 比较差异 git difftool \u0026ndash;dir-diff\n\u0026ndash;depth=1 建议不想给项目做贡献或者看历史啥的就用这个就好了。\n\u0026ndash;recursive 在有子目录的时候需要用： git clone --recursive\n-b clone 的时候可以指定分支，例如：\ngit clone -b 4.27.2-release --depth=1 git@github.com:EpicGames/UnrealEngine.git\n功能记录 cherry pick 如果只想要某个commit，不需要直接把branch全部合入过来，可以用 cherry pick： https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html\nreset 想把commit的东西给回退到本地，更改后或者pull后重新commit上去，可以用 git reset https://juejin.cn/post/6844904185129861128\nsubmodule 更新 git submodule update --init --recursive\nUbuntu Git https://blog.csdn.net/Chenftli/article/details/81141010\n关于 git@github.com: Permission denied (publickey). https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\nhttps://docs.github.com/cn/authentication/troubleshooting-ssh/error-permission-denied-publickey\nGitHub 查看 history https://blog.csdn.net/weixin_30615767/article/details/100091029\n设置默认分支 fork的项目升级 https://zhuanlan.zhihu.com/p/291845721\n指明我们需要同步的仓库：\ngit remote add upstream https://github.com/OriginalRepo/OriginalProject.git\n拉取更新的 branches 和 commits： git fetch upstream\n合并： git merge upstream/master\n","date":"2022-03-21T00:00:00Z","permalink":"https://hebohang.github.io/p/git/","title":"Git"}]