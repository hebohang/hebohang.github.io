[{"content":"概览 在 UE5 推出了服务于大世界的 World Partition 系统，总的来说主要分几大块：\nGrid、Level（Grid Level，非 ULevel）、Cell 的划分 OFPA Level Instance Data Layer HLOD 还有一些也与之相关，例如之前研究过的 LandscapeSpline 也在 WP 版本有特殊的实现方式。\nhttps://docs.unrealengine.com/5.3/zh-CN/world-partition-in-unreal-engine/\n以下代码均为 5.3 版本对应代码。\nGrid、Level、Cell 的划分 WP 与 UWorld、ULevel 的串连 我们知道，UE中，一个 UWorld 由各个 ULevel 组织而成，每个 ULevel 则拥有一个对应的设置信息记录 AWorldSettings： https://zhuanlan.zhihu.com/p/22924838\nAWorldSettings 对应编辑器中的 World Settings 面板，也是保存 UWorldPartition 的容器： 这里使用的是 UE5 新增的 TObjectPtr，方便序列化反序列化，可参考： https://zhuanlan.zhihu.com/p/504115127\n我们在编辑器新打开一个 World Partition 地图的时候（File-\u0026gt;New Level-\u0026gt;Open World），会调用 FEditorFileUtils::LoadMap(*MapPackageFilename, /*bLoadAsTemplate=*/true); 去加载一个大世界模板地图，接着加载 AWorldSettings 的时候就会把对应 WorldPartition 随之加载进来。\n当然，既然是 UObject 我们也可以直接 NewObject\u0026lt;UWorldPartition\u0026gt;(WorldSettings);\n在 UWorld、ULevel 中则均有 GetWorldPartition 方法，实现均是拿到对应 WorldSettings（UWorld 则是拿对应 PersistentLevel 的 WorldSettings）的 WorldPartition： 对于 UWorld 我们也有 IsPartitionedWorld 方法来判断是否是 WP 版本： bool IsPartitionedWorld() const { return GetWorldPartition() != nullptr; }\n因此我们可以这样写：\n1 2 3 if (Actor-\u0026gt;GetWorld() \u0026amp;\u0026amp; Actor-\u0026gt;GetWorld()-\u0026gt;IsPartitionedWorld()) { } UWorldPartition 既然 WP 是保存在 AWorldSettings 中，编辑器下我们就可以调整对应设置： 引擎为其定制了此面板，可参考：Engine\\Source\\Editor\\WorldPartitionEditor\\Private\\WorldPartition\\Customizations\\WorldPartitionDetailsCustomization.h\n有几处设置需要细讲，我们先回到 UWorldPartition 这个类，他本身继承自 UObject、FActorDescContainerCollection、IWorldPartitionCookPackageGenerator， 也就是说他本身就存放有所有的 ActorDesc，在 UActorDescContainer 的 ActorsByName 中：\n1 2 using FNameActorDescMap = TMap\u0026lt;FName, TUniquePtr\u0026lt;FWorldPartitionActorDesc\u0026gt;*\u0026gt;; FNameActorDescMap ActorsByName; 这里的 ActorDesc 即 FWorldPartitionActorDesc 类型十分重要，他保存有 Guid、ActorPackage、ActorPath 等离线信息（即保存在资产中的信息）以及 AActor的指针 ActorPtr、引用计数等运行时信息（即运行游戏才有的信息）。为后续划分所属 Cell（GenerateStreaming）等功能服务。\n我们可以用 wp.Editor.DumpActorDescs hbh_test.csv 指令把他们都 dump 出来，参数是文件路径。\n接着回到编辑器面板，对应 UWorldPartition 的：\n我们的 RuntimeHash 除非特殊需要自己定制，否则都是走默认的 UWorldPartitionRuntimeSpatialHash，在World Settings中可以修改， 那么接下来的 Preview Grids 以及 Grids 与 Debug Color 等设置则都属于 UWorldPartitionRuntimeSpatialHash： 可以看到他们都被 WITH_EDITORONLY_DATA 包裹，真正运行游戏时，最重要的 Cell Size、Loading Range 等信息会被重新安置给 StreamingGrids： 而这一过程则是在最重要的 GenerateStreaming 函数中完成的：\nGrid、Level、Cell 的基础含义 在进入正式分析之前，再简单说一下这三个的意思。\nGrid 是棋盘，Cell 是格子，Level 则是分层管理。每一级 Level 都有自己的格子，即自己的 Cell Size，每两级 Level 之间的 Cell Size 是乘 2 的关系， 即格子放大四倍（宽、高都乘上了2）。\nLevel 0 的 Cell Size 是 WP 面板上填的数值，也是最小的 Cell Size，最大的一级 Level 则会覆盖整个世界，因此我们只需要知道 Level 的 总个数以及面板上自己设定的 Cell Size，就知道了每一级 Level 的 Cell Size，具体函数如下（会在 UWorldPartitionRuntimeSpatialHash 的 GenerateStreaming 函数中调用，后面章节会详细分析）：\n一个例子如下：\n显然为了内存考虑，一个 Level 只会保存含有 Actor 的那些格子，在这个例子中，我们可以看到 Level 0 有 7 个 Cell，Level 4 则有 25 个；一个 Actor 只会被划分到固定一级 Level 的固定一个 Cell 中。\n初始化：GenerateStreaming 这是 WP 最重要的函数之一，在 UWorldPartition::OnBeginPlay 中我们会调用此函数，来完成对所有 Actor 的划分，决定归属于哪一级 Level 的哪一个 Cell 中，以及 哪些 Actor 会打到一个 Cluster 里面（根据引用关系来）。这样划分好后，我们加载的时候，就只需要根据 Loading Range 来判断覆盖了哪些 Cell，然后去 SpatialHash 中拿到 加载对应 Cell 中的 Actor 所在的 Cluster. 例如 A 引用了 B，而此时 A 所处的 Cell 被覆盖，而 B 所处的 Cell 未被覆盖，那么加载 A 时，由于有引用关系，我们也会把 B 给加载出来， 对于 B 所处 Cell 的其他 Actor 则不予理会。\n我们会调用到 UWorldPartition::GenerateContainerStreaming 中，此时分为三步：\nDump state log\n这一步我们会把WP相关信息都dump出来，和指令 wp.Editor.DumpStreamingGenerationLog 是一样的效果，我们放在后面的 Debug 一节重点讲。当然这一步是做好 dump 的准备工作，在后面的2、3都会执行相关dump操作。\nPreparation Phase\n这一步我们会创建所有的 Container，这里的 Container 即 UActorDescContainer，我们会递归完善所有的 ActorDesc 信息、ActorDescView 信息、Cluster 信息， 打进 Cluster 的相关算法都在 GenerateObjectsClusters 函数中：\nGenerate streaming\n这一步首先我们会创建 Streaming 所需的 Policy，然后根据 Policy 去完成 Actor 的划分（归属于哪一级 Level 的哪一个 Cell）。Policy 在代码中写死的为 UWorldPartitionStreamingPolicy。\nActor 的划分 —— 归属于哪一级 Level 的哪一个 Cell 我们重点来看最后这步：根据 Policy 去完成 Actor 的划分。我们最终会调用到 UWorldPartitionRuntimeSpatialHash 的 GenerateStreaming 函数（如果是默认的 UWorldPartitionRuntimeSpatialHash 的话）：\n在进入 UWorldPartitionRuntimeSpatialHash 的 GenerateStreaming 函数之前，我们首先需要看上图圈出来的 GetStreamingGenerationContext 函数，这一步我们会创建出一个 FStreamingGenerationContext， 在里面我们会把 Preparation Phase 创立的 Cluster 给写到 ActorSetInstances 中，具体可看 FStreamingGenerationContext 的构造函数。\n接着进入 UWorldPartitionRuntimeSpatialHash 的 GenerateStreaming 函数，这里我们会根据 Policy 以及刚刚创立的 StreamingGenerationContext 完成最终 Actor 的划分。大体上又分几个步骤：\n提取面板设置的 Grid 信息\n首先是 UWorldPartition 一节所述，会先提取面板设置的 Grid 信息\n把 ActorSetInstance 写到中间变量 GridActorSetInstances 中\n这一步即包含我们的 Cluster 信息。\n根据 WP 面板设置，完成 Actor 的划分\n重点看 RuntimeSpatialHashGridHelper.cpp 中的 GetPartitionedActors 函数，接下来会详细分析。\n完成最终 FSpatialHashStreamingGrid 的构建\n对应 CreateStreamingGrid 函数。至此初始化完毕。\nGetPartitionedActors 在这里我们又会分几步进行：\n3.1. FSquare2DGridHelper\n关键点是这几个配置：\n这是 5.3 才给出的选项，前两个一般勾选 Disabled ，是为了解决老版本的问题：\n这里保存 Cell 的时候也是仅考虑上面有 Actor 的情形，我们也可以手动调用这个函数来完成一些事情，例如调查有几个 Cell 的小工具：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 if (UWorldPartition* WorldPartition = WorldSettings-\u0026gt;GetWorldPartition()) { UWorldPartition::FGenerateStreamingParams Params; UWorldPartition::FGenerateStreamingContext Context; WorldPartition-\u0026gt;GenerateStreaming(Params, Context); UWorldPartitionRuntimeHash* RuntimeHash = WorldPartition-\u0026gt;RuntimeHash; if (nullptr == RuntimeHash) { continue; } UWorldPartitionRuntimeSpatialHash* RuntimeSpatialHash = Cast\u0026lt;UWorldPartitionRuntimeSpatialHash\u0026gt;(RuntimeHash); if (nullptr == RuntimeSpatialHash) { continue; } int32 CellNum = 0; int32 TotalActorsCount = 0; RuntimeSpatialHash-\u0026gt;ForEachStreamingCells([\u0026amp;](const UWorldPartitionRuntimeCell* RuntimeCell) { CellNum++; TotalActorsCount += RuntimeCell-\u0026gt;GetActorCount(); return true; }); } 这里的 ForEachStreamingCells 方法返回 false 的时候会直接阻断，只有返回 true 的时候才会继续遍历下一个 Cell。\n运行时：Level Streaming 的加载 我们的加载主要是通过 UWorldPartitionLevelStreamingDynamic 完成，他本身就继承自 ULevelStreamingDynamic：\n我们在运行时会更新 World 中的各个 Subsystem，调用 UpdateStreamingState：\n其中和 WP 相关的主要是 UWorldPartitionSubsystem，在他的 UpdateStreamingState 函数中，我们会根据 StreamingPolicy 拿到当前需要加载的 Cell， 再通过 UWorldPartitionStreamingPolicy::SetCellStateToActivated 函数去 Load 这些 Cell：\n这里每个 Cell 会对应一个 UWorldPartitionLevelStreamingDynamic，\n因而加载的时候也是最终调用到 UWorldPartitionLevelStreamingDynamic::Activate\nOFPA ExternalActors 与 ExternalObjects 对于 ExternalObjects，他主要保存的是 Outliner 的文件夹对象，对应 UE 的 UActorFolder 类。\n对于 ExternalActors，他保存的是关卡中的Actor对象，实际上会对Actor调用 SetPackageExternal(true)，最后给 Object 设置上 RF_HasExternalPackage 标记：\n而在序列化时，我们保存的是 UPackage，对于标记了 RF_HasExternalPackage 的 Actor，他的 GetPackage 方法最终会得到 ExternalPackage：\n这段代码的逻辑是，我们会不断拿 ExternalPackage，如果 OuterPrivate 非空且标记了 RF_HasExternalPackage，就会拿到一份 ExternalPackage，如果 OuterPrivate 非空但没标记上 RF_HasExternalPackage，拿到的就是 nullptr； 而如果拿到 nullptr，则会继续追踪 Outer（OuterPrivate），直到没有 Outer，表示到达最顶层，从而拿到最顶层 UPackage\n在 FPackagePath 类中有方法：\n1 2 3 4 5 6 7 8 9 const TCHAR* FPackagePath::GetExternalActorsFolderName() { return TEXT(\u0026#34;__ExternalActors__\u0026#34;); } const TCHAR* FPackagePath::GetExternalObjectsFolderName() { return TEXT(\u0026#34;__ExternalObjects__\u0026#34;); } 编辑器下Actor的加载 对于 ExternalObjects，会在 ULevel::PostLoad 中调用 FExternalPackageHelper::LoadObjectsFromExternalPackages 来加载：\n实际上也就是根据 Level 名字拿到对应 __ExternalObjects__ 路径。例如 Content/HbhTest/NewMap.umap 就会拿到 Content/__ExternalObjects__/HbhTest/NewMap 这个路径从而直接加载里头的所有 Package：\n对于 ExternalActors 也类似，只是挪到了 ULevel::OnLevelLoaded 里面初始化 WorldPartition 的阶段，最后会调用到 UActorDescContainer::Initialize 来加载所有对应 __ExternalActors__ 路径下的 Actor：\n这些 Actor 信息在编辑器情况下最后会被缓存到 WorldPartition 的 EditorHash 中，最后可以根据 XYZ 以及对应 Level 级别得到所有的 Actor：\nDebug Demp大世界场景信息 1 wp.Editor.DumpStreamingGenerationLog 5.3版本可以使用这个命令，输出一次WP的信息（也可以运行一次游戏或者cook的时候），输出结果会在 Saved\\Logs\\WorldPartition 里。\nGrid调试 https://docs.unrealengine.com/5.3/zh-CN/world-partition-in-unreal-engine/\n获取OFPA的Actor的信息 右键可以获取对应的本地路径：\n想获取guid，我测试下来可以这样做：\n视口点击想确定的actor 切换到python命令行 运行指令 print(unreal.get_editor_subsystem(unreal.EditorActorSubsystem).get_selected_level_actors()[0].get_editor_property(\u0026quot;actor_guid\u0026quot;).to_string()) 参考 https://zhuanlan.zhihu.com/p/675514420\nhttps://zhuanlan.zhihu.com/p/610772419\n","date":"2024-02-08T14:39:49+08:00","permalink":"https://hebohang.github.io/p/worldpartition%E8%A7%A3%E6%9E%90/","title":"WorldPartition解析"},{"content":"World Partition 官方文档：\nhttps://docs.unrealengine.com/5.0/zh-CN/world-partition-in-unreal-engine/\n主要是服务于大世界，提供了自动数据管理和基于距离进行加载的关卡流送系统。每个关卡分为是不是 World Partition（下称为WP）的版本，我们可以通过：\n1 2 3 4 UWorld* World = GEditor-\u0026gt;GetEditorWorldContext().World(); if (World-\u0026gt;IsPartitionedWorld()) { } 来判断。\n非WP关卡转换为WP关卡 LandscapeSpline LandscapeSpline与World Partition相关。\n核心函数： LandscapeEdModeSplineTools.cpp： BeginTool、AddControlPoint、AddSegment\nWorldPartition中，特殊的 ALandscapeSplineActor 的Owner是空的，他是通过 LandscapeGuid 和 LandscapeActor 附着到一个 ALandscape 上的。Outer是这个UWorld.\n非 WP 版本，是全部塞到一个 ALandscapeProxy 里面，一个 landscap e有一个 ALandscapeProxy，ALandscapeProxy 里面挂有 ULandscapeSplinesComponent，ULandscapeSplinesComponent， 里面有Segment数组和Control Point数组；\nWP版本则是每个landscape可以挂上多个 ALandscapeSplineActor，每个 ALandscapeSplineActor 里面挂有 ULandscapeSplinesComponent。\nWP-HLOD 还不太清楚 WP 版本的 HLOD 和正常的有什么区别，文档： https://docs.unrealengine.com/5.0/zh-CN/world-partition---hierarchical-level-of-detail-in-unreal-engine/\nOFPA (One File Per Actor) https://zhuanlan.zhihu.com/p/502063482\nWorld Partition下默认开启，非 WP 关卡可以在这里打开：\n蛋疼的事：无法对一个 OFPA 的 Actor 在编辑器下（连接了版本管理）直接更新。\nGrid Cell Runtime Grid 运行时网格，相当于对整个世界划分为一个个格子，每个格子就是 cell，通过 cell size 来控制。\n可以对每个关卡中的物体的detail面板中编辑 World Partition 属性，写上对应属于的Grid的名字。\n参考：\nhttps://www.bilibili.com/video/BV1ik4y1A77p/?spm_id_from=333.337.top_right_bar_window_history.content.click\u0026vd_source=bd08f0c74da1940eb8682f61aa471b24\nhttps://zhuanlan.zhihu.com/p/537589944\nhttps://zhuanlan.zhihu.com/p/502053365\nhttps://zhuanlan.zhihu.com/p/675514420\nhttps://zhuanlan.zhihu.com/p/610772419\nhttps://zhuanlan.zhihu.com/p/541239006\nLevel Instance 每个 Level Instance 也有对应的 WorldSettings（对应 WorldSettings 面板，我们可以打开一个 Level Instance 序列化下来的 Level 来编辑），里头又有对应的 World Partition。\n参考：\nhttps://docs.unrealengine.com/5.3/zh-CN/level-instancing-in-unreal-engine/\nhttps://zhuanlan.zhihu.com/p/502068030\nDebug Demp大世界场景信息 1 wp.Editor.DumpStreamingGenerationLog 5.3版本可以使用这个命令，输出一次WP的信息（也可以运行一次游戏或者cook的时候），输出结果会在 Saved\\Logs\\WorldPartition 里。\nGrid调试 https://docs.unrealengine.com/5.3/zh-CN/world-partition-in-unreal-engine/\n","date":"2024-02-05T18:14:13+08:00","permalink":"https://hebohang.github.io/p/worldpartition/","title":"WorldPartition"},{"content":"调试 条件断点 FString 1 wcsstr((wchar_t*)MyString.Data.AllocatorInstance.Data,L\u0026#34;MyText\u0026#34;) == 0 FName 1 strstr(((FNameEntry\u0026amp;)GNameBlocksDebug[MyFName.DisplayIndex.Value \u0026gt;\u0026gt; FNameDebugVisualizer::OffsetBits][FNameDebugVisualizer::EntryStride * (MyFName.DisplayIndex.Value \u0026amp; FNameDebugVisualizer::OffsetMask)]).AnsiName,\u0026#34;Search substring\u0026#34;) UnrealVS 这是 UE 制作的插件，有很好的功能。\n在 Engine\\Extras\\UnrealVS\\VS2022\\UnrealVS.vsix 中，双击安装即可。\n之后对上面状态栏右键，可以扩展出 UnrealVS 处：\n然后就能很方便地加启动参数了：\ndmp文件 直接拖入VS中:\n这里要注意，我们需要加载 pdb 文件才能调试，可以在设置符号路径处设置，我们这里可以填服务器路径（例如我们项目就是会把 pdb 都上传到一个地址，只需要填 \\xxx.xxx.xxx\\xxx 之类的地址就行）， 服务器路径这个选项要打开：\n配制 bug 代码高亮错误 表现为一堆报红线，网上有两种解决方法，参考： https://forums.unrealengine.com/t/ue-5-1-visualstudio-2022-intellisense-for-engine-files-not-working-in-ue5/551166/19\n方法一：\n方法二： 运行 GenerateProjectFiles.bat 加上 -Engine 参数： .\\GenerateProjectFiles.bat -Engine\n我最后方法一不行试的方法二成功。\n方法三： 某个模块改坏了，导致一直红线。这时候改一下对应的 .Build.cs（随便改然后撤回就行，目的是触发重新检测环境），然后重新 GenerateProjectFiles\n参考 [UFSH2023]总有一个你不知道的虚幻引擎调试技巧 | 陈拓 Epic Games\n","date":"2024-01-17T19:17:46+08:00","permalink":"https://hebohang.github.io/p/ue-vs2022/","title":"UE-VS2022"},{"content":"schtasks 可以启用一个定时任务，可以在 Task Scheduler（任务计划程序）中查看或更改权限等： ","date":"2023-12-25T15:54:56+08:00","permalink":"https://hebohang.github.io/p/bat/","title":"Bat"},{"content":"分析工具 SpaceSniffer.exe\n优化C盘 C盘空间占用太大，可以优化：\n关闭睡眠与休眠功能： powercfg -h off\nhttps://answers.microsoft.com/zh-hans/windows/forum/windows_7-performance/answers-%E5%88%86%E4%BA%ABwindows/21af6481-a388-4bb9-896f-7d4885cea3bb\n","date":"2023-12-15T11:40:29+08:00","permalink":"https://hebohang.github.io/p/%E7%94%B5%E8%84%91%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96/","title":"电脑空间优化"},{"content":"案例 头文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;Commandlets/Commandlet.h\u0026#34; #include \u0026#34;Commandlets/ResavePackagesCommandlet.h\u0026#34; #include \u0026#34;XXXCommandlet.generated.h\u0026#34; DECLARE_LOG_CATEGORY_EXTERN(LogXXXCommandlet, All, All); UCLASS() class UXXXCommandlet : public UResavePackagesCommandlet { GENERATED_BODY() public: UXXXCommandlet(); virtual int32 Main(const FString\u0026amp; InCommandline) override; }; 源文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;XXXCommandlet.h\u0026#34; DEFINE_LOG_CATEGORY(LogXXXCommandlet); UXXXCommandlet::UXXXCommandlet() { } int32 UXXXCommandlet::Main(const FString\u0026amp; InCommandline) { // 可以解析参数 TArray\u0026lt;FString\u0026gt; Tokens; TArray\u0026lt;FString\u0026gt; InSwitches; TMap\u0026lt;FString, FString\u0026gt; ParamsMap; ParseCommandLine(*InCommandline, Tokens, InSwitches, ParamsMap); // do some thing return 0; } 启动/调试时在vs中增加参数：-skipcompile -run=XXX\n这里的 XXX 换成你想要的名字，UResavePackagesCommandlet 也可以换成 UCommandlet\n本地测试：\n1 .\\UnrealEditor.exe E:\\Work\\xxx.uproject -skipcompile -run=XXX skipcompile参数作用 字面意思就是跳过编译，源码对应位置： 参考 https://zhuanlan.zhihu.com/p/512610557\nhttps://zhuanlan.zhihu.com/p/377903983\n","date":"2023-12-11T15:44:01+08:00","permalink":"https://hebohang.github.io/p/commandlet/","title":"Commandlet"},{"content":"使用 源码 窗口的源码位于： Engine\\Plugins\\Editor\\AssetManagerEditor\\Source\\AssetManagerEditor\\Private\\ReferenceViewer\\SReferenceViewer.cpp\n例如对于关卡 Content/Arts/Maps/Login/Login.umap 做引用分析：\n会根据路径得到一个 FAssetIdentifier，接着在 SReferenceViewer::SetGraphRootIdentifiers 设到slate窗口类的成员变量\tUEdGraph_ReferenceViewer* GraphObj 中的 CurrentGraphRootIdentifiers 里面去：\n接着就会在 UEdGraph_ReferenceViewer 进行递归构造引用与被引用节点，通过 AssetRegistry 来获取：\n","date":"2023-12-01T15:15:26+08:00","permalink":"https://hebohang.github.io/p/referenceviewer/","title":"ReferenceViewer"},{"content":"一些小方法 一些小方法\n贴图设置属性 贴图设置属性\nReferenceViewer ReferenceViewer\nCommandlet Commandlet\n保存资产 https://georgy.dev/posts/save-uobject-to-package/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool SaveToAsset(UObject* ObjectToSave) { UPackage* Package = ObjectToSave-\u0026gt;GetPackage(); const FString PackageName = Package-\u0026gt;GetName(); const FString PackageFileName = FPackageName::LongPackageNameToFilename(PackageName, FPackageName::GetAssetPackageExtension()); FSavePackageArgs SaveArgs; // This is specified just for example { SaveArgs.TopLevelFlags = RF_Public | RF_Standalone; SaveArgs.SaveFlags = SAVE_NoError; } const bool bSucceeded = UPackage::SavePackage(Package, nullptr, *PackageFileName, SaveArgs); if (!bSucceeded) { UE_LOG(LogTemp, Error, TEXT(\u0026#34;Package \u0026#39;%s\u0026#39; wasn\u0026#39;t saved!\u0026#34;), *PackageName) return false; } UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Package \u0026#39;%s\u0026#39; was successfully saved\u0026#34;), *PackageName) return true; } HTTP 请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 bool bHttpRequest = false; FString RequestContent; TSharedRef\u0026lt;TJsonWriter\u0026lt;TCHAR, TPrettyJsonPrintPolicy\u0026lt;TCHAR\u0026gt;\u0026gt;\u0026gt; JsonWriter = TJsonWriterFactory\u0026lt;TCHAR, TPrettyJsonPrintPolicy\u0026lt;TCHAR\u0026gt;\u0026gt;::Create(\u0026amp;RequestContent); JsonWriter-\u0026gt;WriteObjectStart(); JsonWriter-\u0026gt;WriteValue(\u0026#34;xxx\u0026#34;, \u0026#34;xxx\u0026#34;); JsonWriter-\u0026gt;WriteObjectEnd(); JsonWriter-\u0026gt;Close(); FHttpModule\u0026amp; HttpModule = FModuleManager::LoadModuleChecked\u0026lt;FHttpModule\u0026gt;(\u0026#34;HTTP\u0026#34;); TSharedRef\u0026lt;IHttpRequest, ESPMode::ThreadSafe\u0026gt; Request = HttpModule.Get().CreateRequest(); Request-\u0026gt;SetVerb(TEXT(\u0026#34;POST\u0026#34;)); Request-\u0026gt;SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json;charset=UTF-8\u0026#34;); Request-\u0026gt;SetURL(\u0026#34;xxxxxx\u0026#34;); Request-\u0026gt;SetContentAsString(RequestContent); Request-\u0026gt;OnProcessRequestComplete().BindLambda( [\u0026amp;bHttpRequest](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) { bHttpRequest = true; if (bSucceeded) { // do some thing } else { // do some thing } }); Request-\u0026gt;ProcessRequest(); while (!bHttpRequest) { FHttpManager\u0026amp; HttpManager = FHttpModule::Get().GetHttpManager(); HttpManager.Tick(0.0f); FPlatformProcess::Sleep(0.0f); } 注意到，我们这里有一个 flag 标志位 bHttpRequest，是为了确保完成http请求再进行后续的操作（不放在回调里），此时需要使用 HttpManager.Tick\n参考： https://blog.csdn.net/qq_51654332/article/details/131489044\n启动时debug 当我们打了一个游戏包，希望断点调试，可以先启动游戏，然后attach到这个进程：\n但是这样做游戏刚开始进行就无法调试到，我们可以增加参数 -WaitForDebugger：\n（可以alt加鼠标左键拖动exe包，生成一个快捷方式，然后给快捷方式添加启动参数）\n此时会无事发生，点击刚刚的attach按钮会看到这个进程，接着会挂在这里(Engine\\Source\\Runtime\\Launch\\Private\\Launch.cpp)：\n点击continue继续就好了。\n修改cpp不打包测试 编辑器运行和打包后运行环境不太一样，走的engine loop的地方也有差别（编辑器下似乎是 UUnrealEdEngine::Tick，打包后是 UGameEngine::Tick）， 因此有时候测试需要打包后测，但是若是只改动部分cpp就要重新打个包会很漫长。\n我们可以把配置改为 Development，然后编译项目（只需编译游戏项目就可以了），编译后在 Binaries\\Win64 下，我们把编译后的游戏 exe 拷贝覆盖之前 打的游戏包（这里只替换exe就行）。但是注意，直接运行 Development 是不可以的，因为相对路径不太一样。\nConsole Variable https://docs.unrealengine.com/5.3/zh-CN/console-varaibles-cplusplus-in-unreal-engine/\n项目打开了 r.GenerateMeshDistanceFields，导致Static Mesh资源检查时都会生成一遍Distance Field，比较耗时，我们在编辑器下 console 里输入 r.GenerateMeshDistanceFields 1，可以发现是只读的： 是因为这个变量有这个flag： 这样写也是报这个read only的错：\n1 2 FString Final = \u0026#34;r.GenerateMeshDistanceFields 0\u0026#34;; GEngine-\u0026gt;Exec(GetWorld(), *Final); 但是根据注释我们仍然可以C++中更改：\n1 UConsoleVariablesEditorFunctionLibrary::SetConsoleVariableByName_Bool(\u0026#34;r.GenerateMeshDistanceFields\u0026#34;, false); 但是commandlet下仍然报错：\n1 LogConsoleVariablesEditor: Error: UConsoleVariablesEditorFunctionLibrary::SetConsoleVariableByName_String: FConsoleVariablesEditorCommandInfo was not foundwith given name: r.GenerateMeshDistanceFields. 在 RenderSettings.h 中，该变量如下：\nread only 属性则对应在这：\n可以改成 ECVF_Default 来作用。\n问题合集 fatal error C1083: Cannot open compiler generated file 主要是打包的时候出现的：\n1 fatal error C1083: Cannot open compiler generated file: \u0026#39;xxxx\u0026#39;: Permission denied 最后发现是这个 xxxx 文件是只读的，右键属性把只读勾掉就行。\nAsset cannot be saved as it has only been partially loaded 根据UE4AnserHub的今年6月最新的回答，已经解决。\n方法：修改文件命名即可。\n缺失 XInput1_3.dll 运行 Engine\\Extras\\Redist\\en-us\\UEPrereqSetup_x64.exe 下载安装依赖项。\nudp日志过多 log里全是这样的日志：\n1 LogUdpMessaging: Warning: FUdpMessageProcessor::UpdateReassemblers Discarding 2/4 of stale message segements from Sender=xxx, Sequence=0 关闭这个插件就行：\n页面文件太小 https://ue5wiki.com/wiki/5cc4f8a/\n材质回退到默认方格块 打开关卡会对 map 进行检测，注意看消息日志。\n我这里是出现某个材质需要勾选 bUsedWithStaticLighting 的选项，勾了就好了。\n合集 https://zhuanlan.zhihu.com/p/80809567\nhttps://docs.unrealengine.com/5.3/en-US/map-check-errors-in-unreal-engine/\n","date":"2023-12-01T15:01:20+08:00","permalink":"https://hebohang.github.io/p/%E6%9D%82%E9%A1%B9/","title":"杂项"},{"content":"官方文档 https://docs.unrealengine.com/5.3/zh-CN/textures-in-unreal-engine/\nhttps://docs.unrealengine.com/5.3/zh-CN/texture-format-support-and-settings-in-unreal-engine/\n属性 Texture Stream 与 LOD Bias https://polycount.com/discussion/200525/ue4-texture-settings-help-mip-gen-settings-lod-bias-power-of-two-mode\nue 的贴图可以勾选 Never Stream，此时会取消纹理流送；否则默认开启纹理流送。\n关闭纹理流送，就可以保证每次都加载贴图原生大小，保证最高分辨率，但是可能有性能影响，一般ui可以开。\n纹理流送首先加载最小的mipmap，然后逐渐增加；如果 LOD Bias 为0，则最后加载到原贴图最大版本为止；为1则为第一级。例如 2048 的贴图，LOD Bias 为1，则纹理流送到 1024 为止。\nTexture Group 纹理组，可以一起设置贴图的各种设置：默认压缩、mip生成、lod bias等等。\n我们主要在 Device Profiles 设定，引擎路径 Engine\\Config\\BaseDeviceProfiles.ini 下有全局的设定：\n项目Project路径\\Config\\DefaultDeviceProfiles.ini 下有各个设备的重载：\n编辑器编辑入口：\nCook 对于贴图的 Cook 的调用栈为：\n可能的分支： 贴图大小综合作用 贴图有 MaxTextureSize、Lod Bias、Texture Group，我们综合作用下，在cook对应平台时，会根据对应 DeviceProfile 以及贴图对应的 group 设置拿到 对应的 lod bias 等设置，例如我们安卓档配的 lod bias 是1，那么在贴图的 MipGenSettings 不为 TMGS_NoMipmaps 的时候，lod bias 会起作用，这时候 贴图的最后 lod bias 会在原始设置基础上增加安卓挡位的 1\n若有 MaxTextureSize，则会在原来的宽高基础上做对应钳制，钳制完再应用 Lod Bias。\n例如，MaxTextureSize 为 512，贴图设置 Lod Bias 为 2，原始宽为 2048，高 1024，MipGenSettings 不为 TMGS_NoMipmaps，对应到安卓档位的 lod bias 为 1；则在最后打安卓cook的时候： 此时 MaxTextureSize 起作用，首先把宽和高钳制，宽到 512，高到 256；接着计算 lod bias，为原始设置 2 加上安卓档位的 1 为 3，因此宽 512 \u0026raquo; 3 为 64，高 256 \u0026raquo; 3 为 32.\n(这只是大体逻辑，更进一步的还会受到其他因素的影响)\n1 2 3 4 5 6 UDeviceProfile* DeviceProfile = UDeviceProfileManager::Get().FindProfile(\u0026#34;Android\u0026#34;); int32 CookedLODBias = 0; if (DeviceProfile) { CookedLODBias = DeviceProfile-\u0026gt;GetTextureLODSettings()-\u0026gt;CalculateLODBias(Texture, false); } 但是我这里发现，我没有在启用编辑器下，也就是 WITH_EDITOR 是 0 的情况下，我测试的贴图的 GetSurfaceWidth 和 GetSurfaceHeight 一直为0，查了很久也不清楚是为什么。\n最后改为了：\n1 CookedLODBias = DeviceProfile-\u0026gt;GetTextureLODSettings()-\u0026gt;CalculateLODBias(Texture-\u0026gt;Source.GetSizeX(), Texture-\u0026gt;Source.GetSizeY(), Texture-\u0026gt;MaxTextureSize, Texture-\u0026gt;LODGroup, Texture-\u0026gt;LODBias, 0, Texture-\u0026gt;MipGenSettings, Texture-\u0026gt;IsCurrentlyVirtualTextured()); ","date":"2023-11-29T11:11:23+08:00","permalink":"https://hebohang.github.io/p/%E8%B4%B4%E5%9B%BE%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7/","title":"贴图设置属性"},{"content":"条件断点 判断字符串是否相等 我们不能用普通的 operator ==，是因为我们在 Debug Conditions 里面不允许有副作用（Side Effects），因此 只能用有限的几个函数： strlen, wcslen, strnlen, wcsnlen, strcmp, wcscmp, _stricmp, _wcsicmp, strncmp, wcsncmp, _strnicmp, _wcsnicmp, strchr, wcschr, strstr, wcsstr\n错误情况（有 side effects）： C++ 1 s.size() \u0026gt; 0 \u0026amp;\u0026amp; strcmp(\u0026amp;s[0], \u0026#34;abc\u0026#34;) == 0 例子：\n参考： https://blog.csdn.net/sinat_41657218/article/details/124686114\nUE5 1 wcscmp((wchar_t*)MyString.Data.AllocatorInstance.Data,L\u0026#34;MyText\u0026#34;) == 0 例子：\n参考： https://forums.unrealengine.com/t/how-to-compare-a-fstring-in-c-condition-breakpoints/358380\n快捷键 跳转到其他代码文件：Ctrl+T 或 Ctrl+,\n跳转到某一行：Ctrl+G\nhttps://learn.microsoft.com/zh-cn/visualstudio/ide/go-to?view=vs-2022\nhttps://leelongcrazy.com/visual-studioshi-yong-kuai-jie-jian.html\n","date":"2023-11-28T15:48:26+08:00","permalink":"https://hebohang.github.io/p/vs2022/","title":"VS2022"},{"content":"Cook 流程 会执行到 UCookCommandlet 的 main 中： Source\\Editor\\UnrealEd\\Private\\Commandlets\\CookCommandlet.cpp\n参考： https://rootjhon.github.io/posts/%E8%B5%84%E6%BA%90Cook%E6%9E%84%E5%BB%BA/\nCook Content https://docs.unrealengine.com/5.3/zh-CN/cooking-content-in-unreal-engine/\nhttps://docs.unrealengine.com/5.3/zh-CN/build-operations-cooking-packaging-deploying-and-running-projects-in-unreal-engine/\n命令行启动 测试命令：\n1 .\\UnrealEditor-Cmd.exe E:\\Work\\xxx\\xxx.uproject -run=cook -targetplatform=Windows -map=TestMap.umap 这里的 .\\ 一定需要，目录在项目路径的 Engine\\Binaries\\Win64 中；但是 -map 我测试没有起作用，还有待考察。\n测完会放在项目目录的 Saved\\Cooked\\Windows\\ 中。\n编辑器与IDE下启动 编辑器下，我们可以点击cook： 此时 Output Log 会有对应 Commandlet（这里的 xxx 是你的项目路径）：\n1 E:\\Work\\xxx\\Engine\\Binaries\\Win64\\UnrealEditor-Cmd.exe E:\\Work\\xxxxxxx\\C7.uproject -run=Cook -TargetPlatform=Windows -unversioned -fileopenlog -abslog=E:\\Work\\xxx\\Engine\\Programs\\AutomationTool\\Saved\\Cook-2023.11.28-15.04.02.txt -stdout -CrashForUAT -unattended -NoLogTimes -UTF8Output 我们可以把对应参数填入 UE5 项目参数中进行调试：\n此时对于贴图的 Cook 的调用栈为：\n可能的分支： ","date":"2023-11-27T19:38:35+08:00","permalink":"https://hebohang.github.io/p/cook/","title":"Cook"},{"content":"获取关卡中一个 Actor 的被引用情况 背景：做合批的时候剔除被引用的 Actor\n例如： 这里的蓝图类就有一个Level中某Actor的硬引用和一个软引用，对于这两个被引用的Actor我们不应该让他被合批。\n最开始使用的是 IsReferenced 这个接口， 但是发现对于软引用无法获取到。\n但是注意到，对于这种情况，我们直接在 Outliner 面板里删除物体，也会弹出被引用的提示警告。\n这个功能位于 UUnrealEdEngine::DeleteActors （Engine\\Source\\Editor\\UnrealEd\\Private\\EditorActor.cpp）\n分别是两个接口： FBlueprintEditorUtils::GetActorReferenceMap AssetToolsModule.Get().FindSoftReferencesToObjects\n这里特别留意到 ALODActor，之前使用 IsReferenced 接口的时候也发现了被其引用的情况：\n具体是为什么会被 ALODActor 引用还不清楚。\n获取特定类型的所有资产 在 Content/Arts 目录中获取所有 Texture：\n1 2 3 4 5 6 7 FARFilter Filter; Filter.PackagePaths.Add(\u0026#34;/Game/Arts\u0026#34;); Filter.ClassPaths.Add(UTexture::StaticClass()-\u0026gt;GetClassPathName()); Filter.bRecursivePaths = true; Filter.bRecursiveClasses = true; TArray\u0026lt;FAssetData\u0026gt; TextureAssets; AssetRegistry.GetAssets(Filter, TextureAssets); 这里注意，我们在 5.1 之后使用的是 ClassPaths 而不是 ClassNames： 获取资产的引用关系 例如获取当前关卡的引用关系：\n获取是谁引用了当前关卡：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto World = GEditor-\u0026gt;GetEditorWorldContext().World(); FName Name = World-\u0026gt;GetPackage()-\u0026gt;GetFName(); FAssetRegistryModule\u0026amp; AssetRegistryModule = FModuleManager::GetModuleChecked\u0026lt;FAssetRegistryModule\u0026gt;(\u0026#34;AssetRegistry\u0026#34;); TArray\u0026lt;FName\u0026gt; AssetReferencers; AssetRegistryModule.Get().GetReferencers(Name, AssetReferencers, UE::AssetRegistry::EDependencyCategory::All); for (int32 i = 0; i \u0026lt; AssetReferencers.Num(); ++i) { TArray\u0026lt;FAssetData\u0026gt; OutAssetData; AssetRegistryModule.Get().GetAssetsByPackageName(AssetReferencers[i], OutAssetData); if (!OutAssetData.IsEmpty()) { UObject* AssetInPackage = OutAssetData[0].GetAsset(); } } 获取当前关卡引用了谁：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto World = GEditor-\u0026gt;GetEditorWorldContext().World(); FName Name = World-\u0026gt;GetPackage()-\u0026gt;GetFName(); FAssetRegistryModule\u0026amp; AssetRegistryModule = FModuleManager::GetModuleChecked\u0026lt;FAssetRegistryModule\u0026gt;(\u0026#34;AssetRegistry\u0026#34;); TArray\u0026lt;FName\u0026gt; DependentAssets; AssetRegistryModule.Get().GetDependencies(Name, DependentAssets, UE::AssetRegistry::EDependencyCategory::All); for (int32 i = 0; i \u0026lt; DependentAssets.Num(); ++i) { TArray\u0026lt;FAssetData\u0026gt; OutAssetData; AssetRegistryModule.Get().GetAssetsByPackageName(DependentAssets[i], OutAssetData); if (!OutAssetData.IsEmpty()) { UObject* AssetInPackage = OutAssetData[0].GetAsset(); } } 这里特别要注意，commandlet 下获取引用关系可能会有问题，需要手动全部加载一次：\n1 2 3 4 UE_LOG(LogTemp, Display, TEXT(\u0026#34;KAutoAssetCheckCommandlet Start Load All Assets!\u0026#34;)) FAssetRegistryModule\u0026amp; AssetRegistryModule = FModuleManager::GetModuleChecked\u0026lt;FAssetRegistryModule\u0026gt;(\u0026#34;AssetRegistry\u0026#34;); AssetRegistryModule.Get().SearchAllAssets(/*bSynchronousSearch =*/true); UE_LOG(LogTemp, Display, TEXT(\u0026#34;KAutoAssetCheckCommandlet Finish Load All Assets!\u0026#34;)) 关于 AssetRegistry，可以参考： https://zhuanlan.zhihu.com/p/76964514\n保存资产 https://zhuanlan.zhihu.com/p/427163748\nhttp://www.bimant.com/blog/ue5-save-upackage/\nxml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 FString OutputFilePath = FPaths::ProjectIntermediateDir() + \u0026#34;xxx/\u0026#34; + \u0026#34;xxx.xml\u0026#34;; const FString XmlTemplate = \u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; encoding=\\\u0026#34;UTF - 8\\\u0026#34;?\u0026gt;\\n\u0026lt;root\u0026gt;\\n\u0026lt;/root\u0026gt;\u0026#34;; FXmlFile* XmlFile = new FXmlFile(XmlTemplate, EConstructMethod::ConstructFromBuffer); if (!XmlFile-\u0026gt;IsValid()) return 0; FXmlNode* XmlRoot = XmlFile-\u0026gt;GetRootNode(); if (XmlRoot == nullptr) return 0; XmlRoot-\u0026gt;AppendChildNode(\u0026#34;Test1\u0026#34;, \u0026#34;test2\u0026#34;, {{\u0026#34;test3\u0026#34;, \u0026#34;test4\u0026#34;}}); XmlFile-\u0026gt;Save(OutputFilePath); delete XmlFile; 结果： ","date":"2023-11-23T18:01:40+08:00","permalink":"https://hebohang.github.io/p/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%96%B9%E6%B3%95/","title":"一些小方法"},{"content":"选择 UE的官方源码是用git管理的： https://github.com/EpicGames/UnrealEngine\n不过项目管理他们更推荐P4（Perforce）\nP4 对于代码文本的管理有些蛋疼，很多项目喜欢混合 git、svn、perforce 使用。\n编辑器 编辑器右下角就有 Source Control 一栏，连上版本控制后我们可以进行 提交、revert 等功能。 点开设置可以进行连接选项的填写：\n源码 由于有这么多种版本控制，ue 统一抽出了接口，位于： Engine\\Source\\Developer\\SourceControl，可以重点观察 Engine/Source/Developer/SourceControl/Public/ISourceControlProvider.h\n例如 P4 则是实现这一接口： Engine/Plugins/Developer/PerforceSourceControl/Source/PerforceSourceControl/Private/PerforceSourceControlProvider.h\n问题（Perforce） Submit Content 时会导致有的文件状态被改为问号（NotInDepot） ue有几次缓存，首先会调用 p4 fstat 命令获取各个文件夹内资产的状态，先记录在中间变量 Records 中（位于文件 PerforceSourceControlOperations.cpp）：\n接着在 ParseUpdateStatusResults 函数中对这个 Records 做处理，根据各个文件的状态，缓存到 OutStates 中（TArray\u0026lt;FPerforceSourceControlState\u0026gt;类型）：\n对于之前在p4服务器被delete的文件（HeadAction 是 delete），会把状态标记为 NotInDepot：\n这样做的原因是，不允许再次存在相同文件的 move/delete 操作，很合理\u0026hellip;\n在处理执行的类文件 PerforceSourceControlProvider.cpp 中，有 GetStateInternal 函数获取文件状态，此时会做一级缓存，存到 StateCache，这是一个文件路径名到 FPerforceSourceControlState 的一个映射， 可以对每次查询状态进行加速，很合理：\n1 TMap\u0026lt;FString, TSharedRef\u0026lt;class FPerforceSourceControlState, ESPMode::ThreadSafe\u0026gt; \u0026gt; StateCache; 我们会在 GetStateInternal 函数中进行处理：\n更新的时候，我们会通过 GetStateInternal 函数得到 StateCache 中对应文件的状态，然后通过 OutStates 中已经拉取的状态去更新：\n至此，看下来都没很合理。但是！我们项目组对一个小写文件改为大写文件，之前的小写文件删除上传p4. p4服务器是Linux环境，文件系统中Linux区分大小写，而Windows不分大小写。 p4此时就有这条delete的记录，在上述操作中就会缓存到ue里的 OutStates\n然后，我们在ue里查询这个大写文件的状态时，由于 StateCache 这个 TMap 默认是不区分大小写的，这就导致谁后进 map 就会把前面的状态覆盖。\n例如本地的这个大写文件状态是 checkout，然后提交查询状态时，map 中的状态又被小写文件的记录覆盖了，从而变成了 NotInDepot \u0026hellip;\n修复方法：把 StateCache 变成一个大小写敏感的 map，修改方法可以参考：\nhttps://hashnode.com/post/case-sensitive-tmaplessfstring-int32greater-in-unreal-engine-4-in-c-ckvc1jse20qf645s14e3d6ntd\nhttps://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/\n事实上也可以参考这个文件：Engine\\Source\\Runtime\\Core\\Private\\Containers\\ContainersTest.cpp\n其中有类 FCaseSensitiveLookupKeyFuncs ，参考他的写法即可\n","date":"2023-11-22T20:22:04+08:00","permalink":"https://hebohang.github.io/p/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/","title":"版本控制"},{"content":"UE 官方主推 P4，在二进制文件上他有加锁的机制，还算能用，但是很贵。\n安装 下载地址： https://www.perforce.com/downloads/helix-visual-client-p4v\nP4最好默认安装在C盘，与后续的UGS使用设置有关。\nP4V 我们的 Depot 和 Workspace 是一个一一对应关系，因此对哪个进行 Checkout 都是一样的。\n1. Reconcile Offline Work 对于没有 Checkout 的文件，默认是锁住的，是一个只读状态。如果我们没有连接 P4 但是又更改为可写状态在其他地方进行了更改，此时就不会加入到 Pending 里面。 （我之前就犯了这个错误，vs连接p4失败了，于是漏了文件没传上去，导致项目构建失败）\n我们可以右键点击 Reconcile Offline Work 来检查一下有没有漏的文件：\n这个指令也就是让 Change list 和本地的情况一致。\n2. Revert Unchanged Files 第二个好用的指令是这个：\n可以自动 Revert 掉没有更改但是被checkout的文件。\nIDE VS2022 对于 VS2022，我们需要安装 P4VS 插件： 此时就可以在Tools-\u0026gt;Options里进行设置： 这里我认为很好用的一个设置是：\n那样对于可写的文件，在保存的时候就会自动 Checkout 上，这样就不用担心漏checkout的问题了。\nRider 由于觉得 VS2022 对于写 UE 有不方便之处，我还是切到了 Rider，对于 Rider 官方就支持 Perforce，无需安装任何插件。\n我们只需要填好这两处即可：\n如果还没生效重启一下就可以了。\n命令行 背景 美术反馈有一个文件，mark for add会报错 Cannot check out \u0026ldquo;exclusive open\u0026rdquo; file(s)，重命名为其他名字就可以add上。\n怀疑是其他人也对同样名字的文件mark for add，但是没有提交，导致被锁住了，p4v里头又看不到是谁，所以就借助命令行查看了。\n初始化p4 1 2 3 4 5 6 7 8 # 设置服务端地址 p4 set P4PORT=perforce.example.com:1666 # 设置 Perforce 用户名 p4 set P4USER=\u0026lt;your-username\u0026gt; # 登录到 Perforce 帐户 p4 login # 输入密码后，设置工作目录 p4 set P4CLIENT=\u0026lt;your-client-workspace\u0026gt; 接着对那个文件使用 opened -a ：\n1 p4 opened -a [filepath] 获取文件状态 1 p4 fstat xxx 这里的 xxx 可以是本地路径（e:\\xxx\\xxx之类），也可以是服务器路径（//xxx/xxx之类），如果是对一个文件夹做检查，可以在最后加上 \u0026hellip; 如 xxx/\u0026hellip;\n搜索Descroption 例如想搜索单号，Powershell 下可以用：\n1 p4 changes -L | select-string \u0026#34;search string\u0026#34; -Context (3,0) 搜出来changelist，p4v 可以查看： 参考： https://stackoverflow.com/questions/134103/how-do-you-search-the-text-of-changelist-descriptions-in-perforce\n","date":"2023-11-21T16:03:52+08:00","permalink":"https://hebohang.github.io/p/perforce/","title":"Perforce"},{"content":"ISM 与 HISM ISM（Instanced Static Meshes）学过图形学的应该都不陌生，走的dc的api接口都有所区别。但是 ISM 需要所有的 Instance 都具有相同的 LOD，也就是说如果远处和近处都是用 ISM 一起渲染的，他们仍然要是一级LOD； 因此对于植被而言，通常覆盖范围较广，但是我们不可能远处和近处都用LOD0，因此又推出了 HISM（Hierarchical instanced static mesh），他把所有的 Instance 分簇，每一簇使用一级 LOD 层。\n因此 HISM 可能每一簇是一个 dc，虽然多了 dc 以及组织结构的管理消耗，但是剔除会更加方便。\n具体原理可以参考：\nhttps://zhuanlan.zhihu.com/p/58963258\nhttps://zhuanlan.zhihu.com/p/441958089\nhttps://zhuanlan.zhihu.com/p/443809005\nhttps://zhuanlan.zhihu.com/p/42949773\n参考： https://www.intel.com/content/www/us/en/developer/articles/training/unreal-engine-4-optimization-tutorial-part-2.html\nHLOD 官方文档： https://docs.unrealengine.com/5.0/zh-CN/hierarchical-level-of-detail-in-unreal-engine/\n针对静态Mesh资产的功能，当模型处于远距离时，分层细节级别（HLOD）系统可以将多个静态网格体Actor合并成单个代理网格体和材质。 生成代理网格体是需要花时间的步骤，并且每次编辑完场景时，左上角可能有需要重新构建HLOD代理网格体的提示（有点像灯光一样，也是有重新构建灯光的步骤）。\nActor合并 一共有四种功能：Merge、Simplify、Batch、Approximate，每一种功能都可以在下面的 Merge Actors Settings 里面进行设置配置。\n官方文档： https://docs.unrealengine.com/5.0/zh-CN/merging-actors-in-unreal-engine/\n相关代码 UE 自带的这个合并功能，其中的 Batch 已经可以达到合批的功能了，其中注册到Editor的主要代码在：\nvoid FLevelEditorContextMenuImpl::FillMergeActorsMenu(UToolMenu* Menu);\n具体功能则是在 IMergeActorsTool 的接口 RunMergeFromSelection 中，可以参考做 Batch 的时候的调用栈：\n做 Batch 的核心函数位于 MeshMergeUtilities.cpp：FMeshMergeUtilities::MergeComponentsToInstances\nbReplaceSourceActors 可以指定是否要把之前的Actor替换为合并后的模型；其中在 FMeshInstancingSettings 可以指定是否依赖 HLOD Volume，可以指定 ISMComponentToUse （我们可以在这里换成 UHierarchicalInstancedStaticMeshComponent::StaticClass()），这个设置就和面板中的是对应起来的。\n最后这个 Batch 功能就可以做到：对于选中的所有 Static Mesh 的 Actor，若能合并（材质、Mesh相同）则合并为一个 HISM，一个 HLOD Volumn 内的要单独合成一个；并且 我们可以指定最小的应该合并的数量（FMeshInstancingSettings-InstanceReplacementThreshold），指定为5就需要有5个能合并的物体才会去合。\n源码修改 如果是HISM，则把HISM内的Instance给重新加入到合批中 这里还把之前的注释掉了，因为我们之前的 HISM 的 Actor 类型就是一个 AActor，会与设置中最后合批的类型 ActorClassToUse 相同，我们不希望被跳过：\nUE源码这里没有指定初始值，经过测试这里的 HLODVolume 可能会沿用之前的 HLODVolume 值，导致最后合批不严格按照 HLODVolume 划分。 我在这里补上了初始值。 组织方式修改：原来ue的功能会把所有不同的mesh都合成一个actor，一种mesh挂一个 ISM 或者 HISM，我们应该是希望一种mesh一个actor 调试一下是这样的：\n核心代码在 FMeshMergeUtilities::MergeComponentsToInstances 的：\n我们这里把 MergedActor 从类 FActorEntry 转移到 FComponentEntry 中了，就完成了我们想要的效果。\n补充说明 可能会改到相关材质资产，比如增加flag bUsedWithInstancedStaticMeshes:\n一键生成碰撞 打开一个 Static Mesh 的资产，在 Collision 这里，如果有 Primitives，则是简单碰撞，一般美术自己编辑的碰撞信息 最后也会进这里面：\n但是如果一个物体没有简单碰撞，UE 则会自动生成一个复杂碰撞（即三角面的碰撞体）：\n这样太费了，我们希望做的是遍历场景所有 Mesh，检查是否有简单碰撞，若没有则自动生成。UE 是有自动生成接口的：\n我们希望生成的是 DOP 的或者 Convex 的。\n相关代码 对应的碰撞信息位于：StaticMesh-\u0026gt;GetBodySetup()-\u0026gt;AggGeom.GetElementCount()\n","date":"2023-11-20T17:27:45+08:00","permalink":"https://hebohang.github.io/p/%E5%9C%BA%E6%99%AF%E4%BC%98%E5%8C%96/","title":"场景优化"},{"content":"ContentBrowser 扩展 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 UToolMenu* Menu = UToolMenus::Get()-\u0026gt;ExtendMenu(\u0026#34;ContentBrowser.AssetContextMenu.AssetActionsSubMenu\u0026#34;); FToolMenuSection\u0026amp; Section = Menu-\u0026gt;FindOrAddSection(\u0026#34;AssetContextAdvancedActions\u0026#34;); Section.AddMenuEntry( \u0026#34;HbhTest\u0026#34;, LOCTEXT(\u0026#34;Hbh Test Title\u0026#34;, \u0026#34;Hbh Test1\u0026#34;), LOCTEXT(\u0026#34;Hbh Test TooltipText\u0026#34;, \u0026#34;Hbh Test2\u0026#34;), FSlateIcon(), FToolMenuExecuteAction::CreateLambda([this](const FToolMenuContext\u0026amp; InContext) { if (UContentBrowserAssetContextMenuContext* Context = InContext.FindContext\u0026lt;UContentBrowserAssetContextMenuContext\u0026gt;()) { for (UObject* Asset : Context-\u0026gt;GetSelectedObjects()) { UE_LOG(LogTemp, Log, TEXT(\u0026#34;%s\u0026#34;), *Asset-\u0026gt;GetPathName()); } } }) ); 对资产右键，效果： 弹窗 自定义一个弹窗：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static const FName TabName(\u0026#34;Your Tab Name\u0026#34;); FGlobalTabmanager::Get()-\u0026gt;RegisterNomadTabSpawner(TabName, FOnSpawnTab::CreateRaw(this, \u0026amp;OnSpawnTab)) .SetDisplayName(LOCTEXT(\u0026#34;xxx\u0026#34;, \u0026#34;xxx\u0026#34;)) .SetMenuType(ETabSpawnerMenuType::Hidden); FGlobalTabmanager::Get()-\u0026gt;UnregisterNomadTabSpawner(TabName); FGlobalTabmanager::Get()-\u0026gt;TryInvokeTab(TabName); TSharedRef\u0026lt;SDockTab\u0026gt; OnSpawnTab(const FSpawnTabArgs\u0026amp; SpawnTabArgs) { return SNew(SDockTab) .TabRole(ETabRole::NomadTab) [ SNew(xxx) ]; } 如果只是想要一个弹出窗口显示信息，可以直接使用 FMessageDialog：\nhttps://docs.unrealengine.com/5.3/en-US/API/Runtime/Core/Misc/FMessageDialog/\nhttps://zhuanlan.zhihu.com/p/268069477\n1 2 3 4 5 FMessageDialog::Open(EAppMsgType::Ok, NSLOCTEXT(\u0026#34;xx\u0026#34;, \u0026#34;xxx\u0026#34;)); int32 Count = 32; FString Dialog = FString::Printf(TEXT(\u0026#34;%d\u0026#34;), Count); FMessageDialog::Open(EAppMsgType::Ok, FText::FromString(Dialog)); 进度条 1 2 3 4 5 6 7 8 9 10 #include \u0026#34;Misc/ScopedSlowTask.h\u0026#34; FScopedSlowTask SlowTask(files.Num(), LOCTEXT(\u0026#34;GeneratingDataText\u0026#34;, \u0026#34;Generating Data\u0026#34;)); SlowTask.MakeDialog(); for (auto\u0026amp; file : files) { SlowTask.EnterProgressFrame();\t//Implementation can be before or after } 参考：\nhttps://forums.unrealengine.com/t/how-can-i-use-unreal-engine-editors-progress-bar-not-umg/359876\nhttps://docs.unrealengine.com/5.3/en-US/API/Runtime/Core/Misc/FScopedSlowTask/\n","date":"2023-11-20T15:28:35+08:00","permalink":"https://hebohang.github.io/p/%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95/","title":"编辑器扩展"},{"content":"编译链接 源码编译 1 git clone -b 4.27.2-release --depth=1 git@github.com:EpicGames/UnrealEngine.git https://zhuanlan.zhihu.com/p/107516361\nhttps://github.com/EpicGames/UnrealEngine\nUE模块、类相关 [YourModuleName]_API宏的作用? 放函数声明前用于暴露(导出)该函数\n放类声明前用于暴露(导出)该类的所有内容\n特别注意：_API前面的内容一定要大写！否则会编译不通过\nMinimalAPI说明符的作用?\n暴露(导出)该类的类型信息让其它模块可以\nCast到该类型 继承该类型 (该类型的所有定义在.cpp文件的虚函数都需要导出) 使用内联函数 编辑器 Content Browser https://docs.unrealengine.com/5.0/zh-CN/content-browser-interface-in-unreal-engine/\n可以对一个文件夹右键 add to favorites 功能，可以显示 favorites：\n关卡 新建 File -\u0026gt; New Level，头两个是 World Partition 的关卡。\nUI 勾掉 auto wrap text，就可以控制自动换行的文本大小（有wrap控制的情况下？）。\n资产 Texture Texture Stream 与 LOD Bias https://polycount.com/discussion/200525/ue4-texture-settings-help-mip-gen-settings-lod-bias-power-of-two-mode\nue 的贴图可以勾选 Never Stream，此时会取消纹理流送；否则默认开启纹理流送。\n关闭纹理流送，就可以保证每次都加载贴图原生大小，保证最高分辨率，但是可能有性能影响，一般ui可以开。\n纹理流送首先加载最小的mipmap，然后逐渐增加；如果 LOD Bias 为0，则最后加载到原贴图最大版本为止；为1则为第一级。例如 2048 的贴图，LOD Bias 为1，则纹理流送到 1024 为止。\nTexture Group 纹理组，可以一起设置贴图的各种设置：默认压缩、mip生成、lod bias等等。\nC++ ue反射相关 入门： https://zhuanlan.zhihu.com/p/400473355 https://www.cnblogs.com/ghl_carmack/p/5701862.html https://ikrima.dev/ue4guide/engine-programming/uobject-reflection/uobject-reflection/\nClass Default Object, 简称CDO UCLASS宏为UObject提供了一个描述其基于虚幻的类型的UCLASS的引用。每个UCLASS都维护一个名为“类默认对象”的对象，简称CDO。\nCDO本质上是一个默认的“模板”对象，由类构造函数生成，之后未修改。可以为给定的Object实例检索UCLASS和CDO，尽管它们通常应该被认为是只读的。可以使用GetClass()函数随时访问Object实例的UCLASS。\nCDO是在引擎初始化时创建的，当引擎为每个类生成UClass对象时。每个UClass的实例都是在引擎初始化期间创建的，并被分配为该UClass的CDO。并且包含在反射系统中，如在编辑器可以操作类蓝图。Obj.cpp可以看到引擎CDO初始化创建。\n因此一个 UClass* 是无法直接Cast转型成其他类型的，因为没有实例化；我们可以用 TSubclassOf 先转为其他类型，之后获取 CDO 得到默认对象（GetDefaultObject\u0026lt;xxx\u0026gt;）再调用它的相关函数之类的。\n获取UObject属性值 https://zhuanlan.zhihu.com/p/61042237\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 获取属性名为PropertyName的属性的值 UObject* Object = ...; FName PropertyName = ...; FProperty* Property = Object-\u0026gt;GetClass()-\u0026gt;FindPropertyByName(PropertyName); if(Property) { void* ValuePtr = Property-\u0026gt;ContainerPtrToValuePtr\u0026lt;void\u0026gt;(Object); if(ValuePtr) { FString Value; Property-\u0026gt;ExportTextItem(Value, ValuePtr, nullptr, nullptr, PPF_None); UE_LOG(LogTemp, Log, TEXT(\u0026#34;Property %s value is %s\u0026#34;), *PropertyName.ToString(), *Value); } } 标记宏 可以使用UENUM()、UCLASS()、USTRUCT()、UFUNCTION()、UPROPERTY()来标记不同的类型和成员变量，标记也可以包含额外的描述关键字。\n每个描述的关键字（例如EditAnywhere或BlueprintCallable）都在ObjectMacros.h中有一个镜像，有一个简短的描述。当不知道一个关键字的意思时，可以去ObjectMacros.h中去查看\n更方便地是直接看文档： https://docs.unrealengine.com/5.3/zh-CN/ufunctions-in-unreal-engine/\n类说明符 UCLASS https://docs.unrealengine.com/5.3/zh-CN/class-specifiers/\n蓝图 UPARAM(ref) https://docs.unrealengine.com/5.3/zh-CN/exposing-gameplay-elements-to-blueprints-visual-scripting-in-unreal-engine/\nWITH_EDITORONLY_DATA 宏 用 WITH_EDITOR 包裹反射属性会在非 Editor 时报错，这是因为 UHT 不会检测宏条件，导致这部分属性也被反射生成了；此时要用 WITH_EDITORONLY_DATA 宏， UE 对这个宏做了特殊处理。\nhttps://ue5wiki.com/wiki/41080/\n指针和引用 参考： https://zhuanlan.zhihu.com/p/604213414\n类指针 UClass* 和 TSubClassOf\n软引用和硬引用 硬引用在资产加载时的逻辑：当A资产持有B资产的硬引用时，A资产被加载到内存中时，B资产也会被加载到内存中。\n软引用在资产加载时的逻辑：当A资产持有B资产的软引用是，A资产被加载到内存中时，B资产不会被加载。\n软引用本质上存的是资产的路径。\n软对象引用：TSoftObjectPtr\u0026lt;T\u0026gt; SoftObjRef;\n软类引用：TSoftClassPtr\u0026lt;T\u0026gt; SoftClassRef;\n因此软引用主要是用来做异步加载的，参考：\nhttps://docs.unrealengine.com/5.3/zh-CN/asynchronous-asset-loading-in-unreal-engine/\nhttps://docs.unrealengine.com/5.3/zh-CN/referencing-assets-in-unreal-engine/\nhttps://zhuanlan.zhihu.com/p/351106187\n源码分析 看类：FSoftObjectPath\n有成员变量： 看注释也知道他是指向一个 Level 中的 Object 的路径，因此持有软引用的时候加载并不会加载资产，可以用 IsPending() 方法来判断是否可以访问。\n继承关系：TSoftObjectPtr 只是对 FSoftObjectPtr 的一个 Wrapper，FSoftObjectPtr 继承自 TPersistentObjectPtr\u0026lt;FSoftObjectPath\u0026gt;\n字符串处理 FString、FName、FText互转 https://docs.unrealengine.com/5.3/zh-CN/string-handling-in-unreal-engine/\nEnum 转 FString 1 UEnum::GetValueAsString(YourEnum::EnumValue) https://forums.unrealengine.com/t/conversion-of-enum-to-string/337869/26\n中文乱码 使用 UTF8_TO_TCHAR：\n1 TextBlock-\u0026gt;SetText(FText::FromString(UTF8_TO_TCHAR(\u0026#34;否\u0026#34;))); 本地化 本地化主要是根据LOCTEXT或者NSLOCTEXT将这两个里面的LOCTEXT(“key”, “value”), 找到这个key，然后根据不同语言，将我们的Value替换掉\n添加namespace域，一方面为了过滤，一方面避免了key冲突。\nLOCTEXT用法\n前后必须要加LOCTEXT_NAMESPACE 和LOCTEXT_NAMESPACE定义一个作用域， 代表下面的字符串都在这里作用域里头，引擎好通过这个域去搜索所有的LOCTEXT\n1 2 3 4 5 #define LOCTEXT_NAMESPACE \u0026#34;SlateMain\u0026#34; .Text(LOCTEXT(\u0026#34;SMainSlate_ButtonSlateAnimation_Text3333\u0026#34;, \u0026#34;测试Slate动画\u0026#34;)) #undef LOCTEXT_NAMESPACE NSLOCTEXT用法\n不用加LOCTEXT_NAMESPACE 和LOCTEXT_NAMESPACE。但是三个参数，第一个也是作用域\n1 .Text(LOCTEXT(\u0026#34;SlateMain\u0026#34;, \u0026#34;SMainSlate_ButtonSlateAnimation_Text3333\u0026#34;, \u0026#34;测试Slate动画\u0026#34;)) UE5在编辑器的 Tools-\u0026gt;Localization Dashboard 中配置： 参考： https://blog.csdn.net/u011718663/article/details/117785611\nhttps://forums.unrealengine.com/t/define-loctext-namespace-something/438086\n路径 各种资源的路径格式：\n1 2 3 4 5 6 7 8 9 ObjectPath: /Engine/EngineDamageTypes/DmgTypeBP_Environmental.DmgTypeBP_Environmental PackageName: /Engine/EngineDamageTypes/DmgTypeBP_Environmental ObjectName: DmgTypeBP_Environmental Filename: ../../../Engine/Content/EngineDamageTypes/DmgTypeBP_Environmental PackagePath: /Engine/EngineDamageTypes ShortName: DmgTypeBP_Environmental AssetName: DmgTypeBP_Environmental AssetPackageExtension: .uasset MapPackageExtension: .umap 路径转换函数：\n1 2 3 4 5 6 7 8 9 10 FString ObjectPath = TEXT(\u0026#34;/Engine/EngineDamageTypes/DmgTypeBP_Environmental.DmgTypeBP_Environmental\u0026#34;); FString PackageName = FPackageName::ObjectPathToPackageName(ObjectPath); FString ObjectName = FPackageName::ObjectPathToObjectName(ObjectPath); FString Filename = FPackageName::LongPackageNameToFilename(PackageName); FString PackageName2 = FPackageName::FilenameToLongPackageName(Filename); FString PackagePath = FPackageName::GetLongPackagePath(PackageName); FString ShortName = FPackageName::GetLongPackageAssetName(PackageName); FString AssetName = FPackageName::GetShortName(PackageName); FString AssetPackageExtension = FPackageName::GetAssetPackageExtension(); FString MapPackageExtension = FPackageName::GetMapPackageExtension(); 想得到 ObjectPath，我一直没发现好办法，但是从 PackageName 到 ObjectPath 可以先得到 FAssetData 过度：\n1 2 TArray\u0026lt;FAssetData\u0026gt; AssetDataArray; AssetRegistryModule.Get().GetAssetsByPackageName(*AssetPackageName, AssetDataArray); https://zhuanlan.zhihu.com/p/152201635\n复制 Duplicate 1 2 3 4 5 6 7 8 9 10 // 1. Duplicate Object YourType* NewObject = DuplicateObject\u0026lt;YourType\u0026gt;(const TObjectPtr\u0026lt;T\u0026gt;\u0026amp; SourceObject, UObject* Outer, const FName Name = NAME_None) // 2. Duplicate Actor UEditorActorSubsystem* EditorActorSubsystem = GEditor-\u0026gt;GetEditorSubsystem\u0026lt;UEditorActorSubsystem\u0026gt;(); YourType* NewActor = Cast\u0026lt;YourType\u0026gt;(EditorActorSubsystem-\u0026gt;DuplicateActor(YourActor, World)); // 3. Duplicate Asset FAssetToolsModule\u0026amp; AssetToolsModule = FModuleManager::LoadModuleChecked\u0026lt;FAssetToolsModule\u0026gt;(\u0026#34;AssetTools\u0026#34;); UObject* NewAsset = AssetToolsModule.Get().DuplicateAsset(\u0026#34;NewAssetName\u0026#34;, \u0026#34;NewAssetPath\u0026#34;, YourAsset); Slate专栏 快速入门指南 官方教程： https://docs.unrealengine.com/5.0/zh-CN/slate-editor-window-quickstart-guide-for-unreal-engine/\n但是官方教程有一点错误，详细代码可以看： https://github.com/yegorsw/UE_SimpleSlatePlugin/tree/main\n细节面板自定义 https://zhuanlan.zhihu.com/p/463008792\nhttps://imzlp.com/posts/26919/\n其中若是对TArray类型自定义，我是参考的ue源代码，参考链接： https://forums.unrealengine.com/t/how-to-use-ipropertytypecustomization-to-display-tarray/414634/7\n最后翻看ue代码：FSpriteDetailsCustomization::BuildTextureSection\n1 2 3 TSharedRef\u0026lt;FDetailArrayBuilder\u0026gt; PropertyValuesBuilder = MakeShareable(new FDetailArrayBuilder(PropertyValuesHandle.ToSharedRef())); PropertyValuesBuilder-\u0026gt;OnGenerateArrayElementWidget(FOnGenerateArrayElementWidget::CreateSP(this, \u0026amp;FKCustomPropertyDetails::GeneratePropertyValueWidget)); StructBuilder.AddCustomBuilder(PropertyValuesBuilder); 关闭代码文件优化 https://zhuanlan.zhihu.com/p/563164847 可以按vs的方式：\n1 2 #pragma optimize(\u0026#34;\u0026#34;, off) #pragma optimize(\u0026#34;\u0026#34;, on) 配置文件 https://docs.unrealengine.com/5.2/zh-CN/configuration-files-in-unreal-engine/\n","date":"2023-11-17T15:56:23+08:00","permalink":"https://hebohang.github.io/p/ue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"UE基础知识"},{"content":"常用命令 1 2 3 4 5 6 7 8 # 本地预览 hugo server # 预览特定config hugo --config=config-HEngine.yaml server # 新建文章（指定文章路径） hugo new post/xxx/xxx/index.md # 提交 git add .;git commit -m \u0026#34;update\u0026#34;;git push Hugo链接 官方文档： https://gohugo.io/documentation/\n官方git： https://github.com/gohugoio/hugo\nHugo+Stack 环境配置 我们选用的是stack主题： https://github.com/CaiJimmy/hugo-theme-stack\n快速入门版本 最开始，我们使用的是stack官方给的快速上手版本：https://github.com/CaiJimmy/hugo-theme-stack-starter ，这个版本直接使用 Hugo module 给串联起来，并且可以直接使用 GitHub 的 codespace 直接上手写博客。\n但是用这种版本会有一些问题：\ncodespace启动较慢，不如本地写 因为没有用源码，所以要么是自己fork一份stack theme再改自己仓库对应的主题地址，要么就不能对主题进行定制化修改 基于此，最后我还是选择了源码+本地环境配置的写法。当然 codespace 仍然是可以用的。\n本地环境配置 安装hugo\n根据官方建议，我们选择下载扩展版本： 根据我的本机环境，我下载的是hugo_extended_0.120.4_windows-amd64.zip版本。\n安装完成后可以用 hugo version 查看版本，检查是否安装成功。\n安装go语言\nhugo选择是go作为构建语言，这种编译型的语言有着天然的速度优势，因此几乎可以做到实时预览，这也是我选择hugo的主要原因。\n初始化博客环境\nhugo new site blog\n这样就会新建立blog文件夹，并且包含hugo的基本环境。\n下载主题源码\n我这里选用的stack主题，直接在stack的仓库拉一份release版本的，放在我们刚刚的博客环境中的themes文件夹中（若没有则新建）。\n一般主题都会有一个 exampleSite 文件夹，拷贝到博客根目录就ok了。\nCI流程 博客仓库托管于 Github，我们自然是使用 Github Action 进行自动部署的 CI（continuous integration）流程。事实上，前面的stack快速版本就已经给了这样的文件了。\n但是不幸的是他还有点问题，他的部署流程使用的是 JamesIves/github-pages-deploy-action@v4，但是我没有成功。我最后改成了使用 peaceiris/actions-gh-pages@v3：\n1 2 3 4 5 6 7 8 - name: Deploy 🚀 uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: 这里填写你的 GitHub 的 token EXTERNAL_REPOSITORY: 这里填你部署的地址，我的是 hebohang/hebohang.github.io PUBLISH_BRANCH: hugo PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 关于TOKEN 这里需要注意，我们应该给token对应的权限以让他可以使用 GitHub Workflow（而之前hexo的部署是使用hexo指令的，就没有加权限的步骤）。\n使用多个主题 本地可以这样测试：hugo --config=config-HEngine.yaml server\n使用多个config以指定不同的theme。\nhttps://discourse.gohugo.io/t/two-themes-as-separate-hugo-directories-deployed-to-the-same-website/27899/4\nhttps://github.com/peaceiris/actions-gh-pages/issues/324\n关于stack主题 文档：https://stack.jimmycai.com/config/menu\n说明 博客中链接需要单独起一行才生效。 如果创建多级文件夹时文章文件名不是 index.md 或者类别、标签文件名不是 _index.md 的话，设置封面图片会出现问题。 扩展 代码块 tab为4个字符宽不生效 参考：\nhttps://discourse.gohugo.io/t/chroma-syntax-highlighter-and-tabwidth/31455/5\n需要在 themes\\hugo-theme-stack\\assets\\scss\\partials\\highlight\\common.scss 后面添加：\n1 2 3 pre.chroma { -moz-tab-size:4;-o-tab-size:4;tab-size:4; } 开启waline评论 主要见此链接： https://waline.js.org/guide/get-started/\n一直配置完 Vercel 部署这一步：\n点击 Visit，此时的网址即为服务端地址，然后直接填到 Stack 模板中：\n即可开启 waline 评论。\n参考： https://imayx.top/waline/\nSub Category 我一直想要这个功能，目前看到最漂亮的是 Jekyll 的主题 chirpy，演示Demo： https://chirpy.cotes.page/\n但是 Hugo 似乎支持的不好，看到一个一样想法的相关讨论： https://discourse.gohugo.io/t/categories-sections-with-hierarchy/3058\n但是 Hugo 也看到一个移植过来的主题实现了这个功能： https://github.com/kakawait/hugo-tranquilpeak-theme\n之后再试试。\n归档三栏 在 /assets/scss/custom.scss 中加入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 归档页面三栏 @media (min-width: 1024px) { .article-list--compact { display: grid; grid-template-columns: 1fr 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; border-radius: 16px; } } } 参考： https://www.xalaok.top/post/stack-modify/#%E5%8F%8C%E6%A0%8F\n最后更新时间 hugo-theme-stack\\layouts\\_default\\single.html\n但是这里我在 single.html 中加了总有点不对，去掉也能作用，只是没有按照想要的格式，按照默认的格式去作用的。 后来发现只是本地测试正确，部署之后显示还是不太对。目前没有启用这一功能了。\n参考： https://blog.yfei.page/cn/2021/03/lastmod-hugo/\n页面宽度 调整 themes\\hugo-theme-stack\\assets\\scss\\grid.scss\n图片糊 我把这里调成false就好了： 更进一步或许该参考： https://gohugo.io/content-management/image-processing/\n参考链接 https://yelleis.top/p/61fdb627/#%E6%98%BE%E7%A4%BA%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E6%96%87%E7%AB%A0%E6%95%B0%E7%9B%AE\n参考 https://blog.reincarnatey.net/2023/build-hugo-blog-with-stack-mod/#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2\nhttps://digitaldrummerj.me/series/blogging-with-hugo/\n","date":"2023-11-15T16:20:34+08:00","image":"https://hebohang.github.io/p/hugo/image-1_hu8bfe0da041acf9635cac8731e36b058a_148455_120x120_fill_box_smart1_3.png","permalink":"https://hebohang.github.io/p/hugo/","title":"Hugo"},{"content":"建站选型 博客分静态博客和动态博客，静态博客维护成本小，因此我这里选择的是静态博客的方式。主流的几个静态博客框架是jekyll、hexo和hugo，我们这里使用的是 Hexo 进行静态博客的生成，随后部署在Github Pages上。\n主要参考的链接是：https://blog.csdn.net/yaorongke/article/details/119089190\n关于Hexo 文档：documentation\n疑问：troubleshooting\nGithub：GitHub\n常用指令 Windows Powershell 多个指令不能用 \u0026amp;\u0026amp; 了，我们可以使用分号 ;\n我的常用指令：\n1 2 3 4 5 hexo clean hexo g hexo s hexo d hexo g -d 因此本地测试我们可以直接：\n1 hexo clean; hexo g; hexo s 一步到位。\n部署的时候可以：\n1 hexo clean; hexo g; hexo d 或者\n1 hexo g -d Quick Start 新建博客 1 $ hexo new \u0026#34;My New Post\u0026#34; More info: Writing\n本地起一个服务器 1 $ hexo server More info: Server\n主要是用于本地自测，可以简单用写： hexo s\nGenerate static files 1 $ hexo generate More info: Generating\n本地生成，hexo g 一键部署.\nDeploy to remote sites 1 $ hexo deploy More info: Deployment\n我们配好部署网站后端后，就可以直接用 hexo g -d\n关于Next 我们选择的主题theme是Next主题，参考使用文档： https://theme-next.iissnan.com/getting-started.html\nGithub位置：https://github.com/theme-next/hexo-theme-next\n","date":"2023-11-11T16:17:13+08:00","permalink":"https://hebohang.github.io/p/hexo/","title":"Hexo"},{"content":"静态博客与动态博客 静态博客和动态博客是两种不同类型的博客系统。\n区别 静态博客是把所有的博客文章预先生成好的静态页面，并存储在服务器上。当用户请求访问某篇博客时，服务器会直接返回对应的静态页面，不需要动态生成。 因此，静态博客通常比较快，安全性也较高，但是缺点是不能提供动态内容，例如评论功能，数据统计功能等。 不过我们可以想办法做到无后端的模拟动态的行为，比如说 Valine 就是一个无后端的评论系统。\n动态博客则是在用户请求时才动态生成博客页面。动态博客通常可以提供更多的功能，例如评论，数据统计，分类标签等。 但是，动态博客的响应速度较慢，安全性也较低，因为每次请求都需要从数据库中动态生成博客页面。\n流行框架 静态博客的流行框架有： Jekyll、 Hexo 和 Hugo\n动态博客的流行框架有： Typecho、 WordPress 和 zblog\n选择 我只是打算整理好笔记，以供自己以后翻阅以及分享给其他人查阅，并不想折腾后端，因此选择了免费的方案： 选一个静态博客框架 + Github Pages 部署。\nHexo 最初我选择的是 Hexo，他使用 nodejs 作为编译所用语言（因为静态博客最后都得编译成静态的html类型）， 选用的 Next 主题，参见：Hexo\n但是感觉编译起来有点难受，我是把博客源文件单独上传到一个仓库：\nhttps://github.com/hebohang/HebohangWebsiteHexo\n每次调用 Hexo 指令再去部署的。主要是每次编译需要花一点时间，不过已经挺快了，知道我遇见了 Hugo。\nHugo Hugo 使用 go 作为编译所用语言，静态型编程语言就是飞快，基本上所见即所得了， 选用的 Stack 主题，参见：Hugo\nJekyll Jekyll 我暂时没有尝试过，听说构建时间比较慢，但是似乎有加速方法？\n但是看到一个主题 chirpy，演示Demo： https://chirpy.cotes.page/\n尤其是这个 Categories 的设计让我觉得很不错。\n","date":"2023-10-21T20:18:02+08:00","permalink":"https://hebohang.github.io/p/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%8A%A8%E6%80%81%E5%8D%9A%E5%AE%A2%E4%B8%8E%E9%80%89%E6%8B%A9/","title":"静态博客、动态博客与选择"},{"content":"想切换成 ssh 协议来 push https://stackoverflow.com/questions/14762034/push-to-github-without-a-password-using-ssh-key\n示例： git add xxx git commit -m \u0026quot;xxx\u0026quot; git remote set-url origin git@github.com:hebohang/glfw.git git push\n错误记录 git submodule: \u0026ldquo;already exists in the index\u0026rdquo; https://stackoverflow.com/questions/12898278/issue-with-adding-common-code-as-git-submodule-already-exists-in-the-index\nOpenSSL SSL_read: git clone 的时候发生的错误。\n这是服务器的SSL证书没有经过第三方机构的签署，所以报错。\n解决方法：git config --global http.sslVerify \u0026quot;false\u0026quot;\nhttps://www.cnblogs.com/jfen625/p/12995408.html\n文件夹大小写问题 貌似 Windows 默认不分大小写，但是我们可以在项目的：.git-\u0026gt;config 中将 ignorecase 手动改为 false\n更新版本 Windows：git bash git update-git-for-windows\n一些参数 比较差异 git difftool \u0026ndash;dir-diff\n\u0026ndash;depth=1 建议不想给项目做贡献或者看历史啥的就用这个就好了。\n\u0026ndash;recursive 在有子目录的时候需要用： git clone --recursive\n-b clone 的时候可以指定分支，例如：\ngit clone -b 4.27.2-release --depth=1 git@github.com:EpicGames/UnrealEngine.git\n功能记录 cherry pick 如果只想要某个commit，不需要直接把branch全部合入过来，可以用 cherry pick： https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html\nreset 想把commit的东西给回退到本地，更改后或者pull后重新commit上去，可以用 git reset https://juejin.cn/post/6844904185129861128\nsubmodule 更新 git submodule update --init --recursive\nUbuntu Git https://blog.csdn.net/Chenftli/article/details/81141010\n关于 git@github.com: Permission denied (publickey). https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\nhttps://docs.github.com/cn/authentication/troubleshooting-ssh/error-permission-denied-publickey\nGitHub 查看 history https://blog.csdn.net/weixin_30615767/article/details/100091029\n设置默认分支 fork的项目升级 https://zhuanlan.zhihu.com/p/291845721\n指明我们需要同步的仓库：\ngit remote add upstream https://github.com/OriginalRepo/OriginalProject.git\n拉取更新的 branches 和 commits： git fetch upstream\n合并： git merge upstream/master\n","date":"2022-03-21T00:00:00Z","permalink":"https://hebohang.github.io/p/git/","title":"Git"}]