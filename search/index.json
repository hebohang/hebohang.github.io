[{"content":"编译链接 源码编译 1 git clone -b 4.27.2-release --depth=1 git@github.com:EpicGames/UnrealEngine.git https://zhuanlan.zhihu.com/p/107516361\nUE模块、类相关 [YourModuleName]_API宏的作用? 放函数声明前用于暴露(导出)该函数\n放类声明前用于暴露(导出)该类的所有内容\n特别注意：_API前面的内容一定要大写！否则会编译不通过\nMinimalAPI说明符的作用?\n暴露(导出)该类的类型信息让其它模块可以\nCast到该类型 继承该类型 (该类型的所有定义在.cpp文件的虚函数都需要导出) 使用内联函数 UI 勾掉 auto wrap text，就可以控制自动换行的文本大小（有wrap控制的情况下？）。\n资产 Texture Texture Stream 与 LOD Bias https://polycount.com/discussion/200525/ue4-texture-settings-help-mip-gen-settings-lod-bias-power-of-two-mode\nue 的贴图可以勾选 Never Stream，此时会取消纹理流送；否则默认开启纹理流送。\n关闭纹理流送，就可以保证每次都加载贴图原生大小，保证最高分辨率，但是可能有性能影响，一般ui可以开。\n纹理流送首先加载最小的mipmap，然后逐渐增加；如果 LOD Bias 为0，则最后加载到原贴图最大版本为止；为1则为第一级。例如 2048 的贴图，LOD Bias 为1，则纹理流送到 1024 为止。\nTexture Group 纹理组，可以一起设置贴图的各种设置：默认压缩、mip生成、lod bias等等。\nC++ ue反射相关 入门： https://zhuanlan.zhihu.com/p/400473355 https://www.cnblogs.com/ghl_carmack/p/5701862.html https://ikrima.dev/ue4guide/engine-programming/uobject-reflection/uobject-reflection/\nClass Default Object, 简称CDO UCLASS宏为UObject提供了一个描述其基于虚幻的类型的UCLASS的引用。每个UCLASS都维护一个名为“类默认对象”的对象，简称CDO。\nCDO本质上是一个默认的“模板”对象，由类构造函数生成，之后未修改。可以为给定的Object实例检索UCLASS和CDO，尽管它们通常应该被认为是只读的。可以使用GetClass()函数随时访问Object实例的UCLASS。\nCDO是在引擎初始化时创建的，当引擎为每个类生成UClass对象时。每个UClass的实例都是在引擎初始化期间创建的，并被分配为该UClass的CDO。并且包含在反射系统中，如在编辑器可以操作类蓝图。Obj.cpp可以看到引擎CDO初始化创建。\n因此一个 UClass* 是无法直接Cast转型成其他类型的，因为没有实例化；我们可以用 TSubclassOf 先转为其他类型，之后获取 CDO 得到默认对象（GetDefaultObject\u0026lt;xxx\u0026gt;）再调用它的相关函数之类的。\n获取UObject属性值 https://zhuanlan.zhihu.com/p/61042237\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 获取属性名为PropertyName的属性的值 UObject* Object = ...; FName PropertyName = ...; FProperty* Property = Object-\u0026gt;GetClass()-\u0026gt;FindPropertyByName(PropertyName); if(Property) { void* ValuePtr = Property-\u0026gt;ContainerPtrToValuePtr\u0026lt;void\u0026gt;(Object); if(ValuePtr) { FString Value; Property-\u0026gt;ExportTextItem(Value, ValuePtr, nullptr, nullptr, PPF_None); UE_LOG(LogTemp, Log, TEXT(\u0026#34;Property %s value is %s\u0026#34;), *PropertyName.ToString(), *Value); } } 标记宏 可以使用UENUM()、UCLASS()、USTRUCT()、UFUNCTION()、UPROPERTY()来标记不同的类型和成员变量，标记也可以包含额外的描述关键字。\n每个描述的关键字（例如EditAnywhere或BlueprintCallable）都在ObjectMacros.h中有一个镜像，有一个简短的描述。当不知道一个关键字的意思时，可以去ObjectMacros.h中去查看\n更方便地是直接看文档： https://docs.unrealengine.com/5.3/zh-CN/ufunctions-in-unreal-engine/\n类说明符 UCLASS https://docs.unrealengine.com/5.3/zh-CN/class-specifiers/\n蓝图 UPARAM(ref) https://docs.unrealengine.com/5.3/zh-CN/exposing-gameplay-elements-to-blueprints-visual-scripting-in-unreal-engine/\n字符串处理（FString、FName、FText互转） https://docs.unrealengine.com/5.3/zh-CN/string-handling-in-unreal-engine/\n中文乱码 使用 UTF8_TO_TCHAR：\n1 TextBlock-\u0026gt;SetText(FText::FromString(UTF8_TO_TCHAR(\u0026#34;否\u0026#34;))); Slate专栏 快速入门指南 官方教程： https://docs.unrealengine.com/5.0/zh-CN/slate-editor-window-quickstart-guide-for-unreal-engine/\n但是官方教程有一点错误，详细代码可以看： https://github.com/yegorsw/UE_SimpleSlatePlugin/tree/main\n细节面板自定义 https://zhuanlan.zhihu.com/p/463008792\nhttps://imzlp.com/posts/26919/\n其中若是对TArray类型自定义，我是参考的ue源代码，参考链接： https://forums.unrealengine.com/t/how-to-use-ipropertytypecustomization-to-display-tarray/414634/7\n最后翻看ue代码：FSpriteDetailsCustomization::BuildTextureSection\n1 2 3 TSharedRef\u0026lt;FDetailArrayBuilder\u0026gt; PropertyValuesBuilder = MakeShareable(new FDetailArrayBuilder(PropertyValuesHandle.ToSharedRef())); PropertyValuesBuilder-\u0026gt;OnGenerateArrayElementWidget(FOnGenerateArrayElementWidget::CreateSP(this, \u0026amp;FKCustomPropertyDetails::GeneratePropertyValueWidget)); StructBuilder.AddCustomBuilder(PropertyValuesBuilder); 关闭代码文件优化 https://zhuanlan.zhihu.com/p/563164847 可以按vs的方式：\n1 2 #pragma optimize(\u0026#34;\u0026#34;, off) #pragma optimize(\u0026#34;\u0026#34;, on) ","date":"2023-11-17T15:56:23+08:00","permalink":"https://hebohang.github.io/p/ue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"UE基础知识"},{"content":"常用命令 1 2 3 4 5 6 7 8 # 本地预览 hugo server # 预览特定config hugo --config=config-HEngine.yaml server # 新建文章（指定文章路径） hugo new post/xxx/xxx/index.md # 提交 git add .;git commit -m \u0026#34;update\u0026#34;;git push Hugo链接 官方文档： https://gohugo.io/documentation/\n官方git： https://github.com/gohugoio/hugo\nHugo+Stack 环境配置 我们选用的是stack主题： https://github.com/CaiJimmy/hugo-theme-stack\n快速入门版本 最开始，我们使用的是stack官方给的快速上手版本：https://github.com/CaiJimmy/hugo-theme-stack-starter ，这个版本直接使用 Hugo module 给串联起来，并且可以直接使用 GitHub 的 codespace 直接上手写博客。\n但是用这种版本会有一些问题：\ncodespace启动较慢，不如本地写 因为没有用源码，所以要么是自己fork一份stack theme再改自己仓库对应的主题地址，要么就不能对主题进行定制化修改 基于此，最后我还是选择了源码+本地环境配置的写法。当然 codespace 仍然是可以用的。\n本地环境配置 安装hugo\n根据官方建议，我们选择下载扩展版本： 根据我的本机环境，我下载的是hugo_extended_0.120.4_windows-amd64.zip版本。\n安装完成后可以用 hugo version 查看版本，检查是否安装成功。\n安装go语言\nhugo选择是go作为构建语言，这种编译型的语言有着天然的速度优势，因此几乎可以做到实时预览，这也是我选择hugo的主要原因。\n初始化博客环境\nhugo new site blog\n这样就会新建立blog文件夹，并且包含hugo的基本环境。\n下载主题源码\n我这里选用的stack主题，直接在stack的仓库拉一份release版本的，放在我们刚刚的博客环境中的themes文件夹中（若没有则新建）。\n一般主题都会有一个 exampleSite 文件夹，拷贝到博客根目录就ok了。\nCI流程 博客仓库托管于 Github，我们自然是使用 Github Action 进行自动部署的 CI（continuous integration）流程。事实上，前面的stack快速版本就已经给了这样的文件了。\n但是不幸的是他还有点问题，他的部署流程使用的是 JamesIves/github-pages-deploy-action@v4，但是我没有成功。我最后改成了使用 peaceiris/actions-gh-pages@v3：\n1 2 3 4 5 6 7 8 - name: Deploy 🚀 uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: 这里填写你的 GitHub 的 token EXTERNAL_REPOSITORY: 这里填你部署的地址，我的是 hebohang/hebohang.github.io PUBLISH_BRANCH: hugo PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 关于TOKEN 这里需要注意，我们应该给token对应的权限以让他可以使用 GitHub Workflow（而之前hexo的部署是使用hexo指令的，就没有加权限的步骤）。\n使用多个主题 本地可以这样测试：hugo --config=config-HEngine.yaml server\n使用多个config以指定不同的theme。\nhttps://discourse.gohugo.io/t/two-themes-as-separate-hugo-directories-deployed-to-the-same-website/27899/4\nhttps://github.com/peaceiris/actions-gh-pages/issues/324\n关于stack主题 文档：https://stack.jimmycai.com/config/menu\n说明 博客中链接需要单独起一行才生效。 如果创建多级文件夹时文章文件名不是 index.md 或者类别、标签文件名不是 _index.md 的话，设置封面图片会出现问题。 参考 https://blog.reincarnatey.net/2023/build-hugo-blog-with-stack-mod/#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2\n","date":"2023-11-15T16:20:34+08:00","permalink":"https://hebohang.github.io/p/hugo/","title":"Hugo"},{"content":"建站选型 博客分静态博客和动态博客，静态博客维护成本小，因此我这里选择的是静态博客的方式。主流的几个静态博客框架是jekyll、hexo和hugo，我们这里使用的是 Hexo 进行静态博客的生成，随后部署在Github Pages上。\n主要参考的链接是：https://blog.csdn.net/yaorongke/article/details/119089190\n关于Hexo 文档：documentation\n疑问：troubleshooting\nGithub：GitHub\n常用指令 Windows Powershell 多个指令不能用 \u0026amp;\u0026amp; 了，我们可以使用分号 ;\n我的常用指令：\n1 2 3 4 5 hexo clean hexo g hexo s hexo d hexo g -d 因此本地测试我们可以直接：\n1 hexo clean; hexo g; hexo s 一步到位。\n部署的时候可以：\n1 hexo clean; hexo g; hexo d 或者\n1 hexo g -d Quick Start 新建博客 1 $ hexo new \u0026#34;My New Post\u0026#34; More info: Writing\n本地起一个服务器 1 $ hexo server More info: Server\n主要是用于本地自测，可以简单用写： hexo s\nGenerate static files 1 $ hexo generate More info: Generating\n本地生成，hexo g 一键部署.\nDeploy to remote sites 1 $ hexo deploy More info: Deployment\n我们配好部署网站后端后，就可以直接用 hexo g -d\n关于Next 我们选择的主题theme是Next主题，参考使用文档： https://theme-next.iissnan.com/getting-started.html\nGithub位置：https://github.com/theme-next/hexo-theme-next\n","date":"2023-11-11T16:17:13+08:00","permalink":"https://hebohang.github.io/p/hexo/","title":"Hexo"}]